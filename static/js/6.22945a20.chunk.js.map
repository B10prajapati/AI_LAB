{"version":3,"sources":["components/CodeBlock.jsx","snippets/index.js","../node_modules/@material-ui/core/esm/CardActions/CardActions.js","../node_modules/@material-ui/core/esm/Link/Link.js","features/graph/GraphClass.js","components/GraphNode.jsx","components/GraphTree.jsx","features/graph/Graph.js","pages/lab2/lab2.js"],"names":["TabPanel","props","children","value","index","other","role","hidden","id","aria-labelledby","CodeBlock","React","useState","setValue","tabNameList","tabCodeSnippetList","language","title","onChange","event","newValue","aria-label","map","name","key","label","a11yProps","codeSnippet","style","dracula","lineProps","wordBreak","whiteSpace","wrapLines","snippets","dfs","bfs","graphClass","water_jug","water_jug_pour_rule","water_jug_rules","water_jug_solution","a_star_search_grid_generation","a_star_search_coord_and_distance","a_star_search_path_calculation","chatbot","chatbot_stem","chatbot_ask","CardActions","ref","_props$disableSpacing","disableSpacing","classes","className","_objectWithoutProperties","_extends","clsx","root","spacing","withStyles","display","alignItems","padding","marginLeft","Link","_props$color","color","_props$component","component","onBlur","onFocus","TypographyClasses","_props$underline","underline","_props$variant","variant","_useIsFocusVisible","useIsFocusVisible","isFocusVisible","onBlurVisible","focusVisibleRef","_React$useState","focusVisible","setFocusVisible","handlerRef","useForkRef","Typography","concat","capitalize","button","underlineNone","textDecoration","underlineHover","underlineAlways","position","WebkitTapHighlightColor","backgroundColor","outline","border","margin","borderRadius","cursor","userSelect","verticalAlign","borderStyle","Graph","addEdge","node","newNode","undefined","graph","push","DFS","rev","stack","length","popped","pop","childData","slice","reverse","i","BFS","queue","shift","this","GraphNode","x_position","y_position","dispatch","useDispatch","strokeColor","useSelector","selectHighlightedNode","x","y","onClick","changeHighlightedNode","cx","cy","r","stroke","strokeWidth","fill","fillOpacity","textAnchor","GraphTree","len","parentName","parentIndex","height","width","selectGraph","renderChildrenList","childObject","childList","countChildren","object","count","Object","keys","varSpacing","g","memo","nodeList","selectNode","highlightedNode","selectBFSPath","selectDFSPath","nodeName","setNodeName","handleNewNodeSubmit","includes","addNode","Grid","direction","container","item","Card","CardContent","data","TextField","plaardceholder","e","target","onKeyPress","Button","showDFS","DFSPath","showBFS","BFSPath","resetGraph","align","window","innerWidth","Lab2","CardHeader","xs","href"],"mappings":"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","file":"static/js/6.22945a20.chunk.js","sourcesContent":["import { Card, CardContent, CardHeader, Tab, Tabs } from \"@material-ui/core\";\nimport React from \"react\";\nimport SyntaxHighlighter from \"react-syntax-highlighter\";\n\nimport { dracula } from \"react-syntax-highlighter/dist/esm/styles/hljs\";\nimport { PropTypes } from \"prop-types\";\nfunction TabPanel(props) {\n  const { children, value, index, ...other } = props;\n\n  return (\n    <div\n      role=\"tabpanel\"\n      hidden={value !== index}\n      id={`simple-tabpanel-${index}`}\n      aria-labelledby={`simple-tab-${index}`}\n      {...other}\n    >\n      {value === index && <> {children} </>}\n    </div>\n  );\n}\n\nTabPanel.propTypes = {\n  children: PropTypes.node,\n  index: PropTypes.any.isRequired,\n  value: PropTypes.any.isRequired,\n};\nfunction a11yProps(index) {\n  return {\n    id: `simple-tab-${index}`,\n    \"aria-controls\": `simple-tabpanel-${index}`,\n  };\n}\nconst CodeBlock = (props) => {\n  const [value, setValue] = React.useState(0);\n\n  const handleChange = (event, newValue) => {\n    setValue(newValue);\n  };\n\n  const { tabNameList, tabCodeSnippetList, language } = props;\n  return (\n    <Card>\n      <CardHeader title=\"Code\" />\n      <CardContent>\n        <Tabs value={value} onChange={handleChange} aria-label=\"Tree Graph\">\n          {tabNameList.map((name, index) => {\n            return <Tab key={index} label={name} {...a11yProps(index)} />;\n          })}\n        </Tabs>\n        {tabCodeSnippetList.map((codeSnippet, index) => {\n          return (\n            <TabPanel value={value} key={index} index={index}>\n              <SyntaxHighlighter\n                language={language}\n                style={dracula}\n                lineProps={{\n                  style: { wordBreak: \"break-all\", whiteSpace: \"pre-wrap\" },\n                }}\n                wrapLines={true}\n              >\n                {codeSnippet}\n              </SyntaxHighlighter>\n            </TabPanel>\n          );\n        })}\n      </CardContent>\n    </Card>\n  );\n};\n\nexport default CodeBlock;\n","export const snippets = {\n  dfs: `\n  DFS = (key, rev = false) => {\n    let dfs = [];\n    this.stack.push(key);\n    while (1) {\n      if (this.stack.length === 0) {\n        // array empty or does not exist\n        break;\n      }\n      const popped = this.stack.pop();\n\n      dfs.push(popped);\n      if (this.graph[popped] === undefined) {\n      } else {\n        let childData;\n        if (rev) childData = this.graph[popped].slice().reverse();\n        else childData = this.graph[popped];\n        for (let i of childData) {\n          this.stack.push(i);\n        }\n      }\n    }\n    return dfs;\n  };`,\n  bfs: `\n  BFS = (key) => {\n    this.queue.push(key);\n    let bfs = [];\n    while (1) {\n      if (this.queue.length === 0) {\n        // array empty or does not exist\n        break;\n      }\n      const popped = this.queue.shift();\n      bfs.push(popped);\n\n      if (this.graph[popped] === undefined) {\n      } else {\n        const childData = this.graph[popped];\n        for (let i of childData) {\n          this.queue.push(i);\n        }\n      }\n    }\n    return bfs;\n  };`,\n  graphClass: `\n  class Graph {\n    constructor() {\n      this.graph = [];\n      this.stack = [];\n      this.queue = [];\n    }\n    addEdge = (node, newNode) => {\n      if (this.graph[node] === undefined) this.graph[node] = [];\n      this.graph[node].push(newNode);\n    };\n  \n    DFS = (key, rev = false) => {\n      let dfs = [];\n      this.stack.push(key);\n      while (1) {\n        if (this.stack.length === 0) {\n          // array empty or does not exist\n          break;\n        }\n        const popped = this.stack.pop();\n  \n        dfs.push(popped);\n        if (this.graph[popped] === undefined) {\n        } else {\n          let childData;\n          if (rev) childData = this.graph[popped].slice().reverse();\n          else childData = this.graph[popped];\n          for (let i of childData) {\n            this.stack.push(i);\n          }\n        }\n      }\n      return dfs;\n    };\n    BFS = (key) => {\n      this.queue.push(key);\n      let bfs = [];\n      while (1) {\n        if (this.queue.length === 0) {\n          // array empty or does not exist\n          break;\n        }\n        const popped = this.queue.shift();\n        bfs.push(popped);\n  \n        if (this.graph[popped] === undefined) {\n        } else {\n          const childData = this.graph[popped];\n          for (let i of childData) {\n            this.queue.push(i);\n          }\n        }\n      }\n      return bfs;\n    };\n  }\n  `,\n  water_jug: `\n  class WaterJug():\n    def __init__(self,x,y,target):\n        self.capX = x\n        self.capY = y\n        self.x = 0\n        self.y = 0\n        self.targe,end='\\\\n\\\\n\\\\n't = target\n        self.path = []\n        \n    def rule(self,x, d=0):\n        w.printVolume()\n        print('Rule {}'.format(x),end=' ')\n        # fill capX gallon jug completely\n        if(x==1):\n                if self.x<self.capX:\n                    self.x=self.capX\n                print('Fill jugX completely')\n        # fill capY gallon jug completely\n        elif (x==2):\n                if self.y<self.capY:\n                    self.y=self.capY\n                print('Fill jugY completely')\n        # pour some part from x jug\n        elif(x==3):\n                if self.x>0:\n                    self.x= self.x - d\n                print('Pour Some part D from X jug')\n        # pour some part from y jug        \n        elif(x==4):\n                if self.y>0:\n                    self.y = self.y - d\n                \n                print('Pour Some part D from Y jug')\n        # empty jug x        \n        elif(x==5):\n                if self.x>0:\n                    self.x=0\n                print('Empty jugX')\n        # empty jug y        \n        elif(x==6):\n                if self.y>0:\n                    self.y=0\n                print('Empty jugY')\n        # pour water from y jug to fill x jug        \n        elif(x==7):\n                if self.x+self.y < self.capX+self.capY:\n                    self.y= self.y-(self.capX-self.x)\n                    self.x = self.capX\n                print('Pour from jugY to fill jugX')\n        #pour water from x jug to fill y jug\n        elif(x==8):\n                if self.x+self.y < self.capX+self.capY:\n                    self.x=self.x-(self.capY-self.y)\n                    self.y = self.capY\n                print('Pour from jugX to fill jugY')\n        # pour all water from y jug to x jug\n        elif(x==9):\n                if self.x+self.y < self.capX:\n                    self.x= self.x+self.y\n                    self.y=0\n                print('Pour all from jugY to jugX')\n        #pour all water from x jug to y jug\n        elif(x==10):\n                if self.x+self.y < self.capY:\n                    self.x=0\n                    self.y=self.x+self.y     \n                    print('Pour all from jugX to jugY')\n\n        w.printVolume()\n        print('---')\n        self.appendPath()\n             \n    def printVolume(self):\n        print('[JugX={}, JugY={}]'.format(self.x, self.y))\n    \n    # print each state leading upto solution\n    def printPath(self):\n        for state in self.path:\n            if state==self.path[-1]:\n                print(f'[JugX:{state[0]}, JugY:{state[1]}]')\n                continue\n            print(f'[JugX:{state[0]}, JugY:{state[1]}]', end='->')\n    \n    # add new state generated to path\n    def appendPath(self):\n        self.path.append([self.x, self.y])\n    \n    def reset(self):\n        self.x=0\n        self.y=0\n        self.path=[]\n        \n    def pour(self): \n        self.reset()\n        yJug= self.capY\n        xJug=0\n#         self.rule(2)\n        step = 1\n        while ((yJug  is not self.target) and (xJug is not self.target)): \n            print('({},{})'.format(xJug, yJug))\n            \n\n            if(yJug < (self.capX-xJug)):\n                temp = yJug\n#                 self.rule(9)\n            else:\n                temp = (self.capX-xJug)\n#                 self.rule(7)\n            xJug = xJug + temp\n            yJug = yJug - temp\n\n#             temp = min(yJug, self.capX-xJug) \n#             xJug = xJug + temp \n#             yJug = yJug - temp \n\n            print('({},{})'.format(xJug, yJug))\n\n            step =  step + 1\n            if ((yJug == self.target) or (xJug == self.target)): \n                break\n\n            if yJug == 0: \n                yJug = self.capY\n#                 self.rule(2)\n                step =  step + 1\n\n            if xJug == self.capX: \n                xJug = 0\n#                 self.rule(5)\n                step =  step + 1\n    \n    # Solve using rules\n    def pourRule(self):\n        self.reset()\n        self.rule(2)\n        step = 1\n        while(1):\n            if(self.y==self.target or self.x==self.target):\n                break\n            \n            if(self.y < (self.capX-self.x)):\n                self.rule(9)\n            else:\n                self.rule(7)\n            \n            step=step+1\n            if(self.y==self.target or self.x==self.target):\n                break\n            \n            if self.y==0:\n                self.rule(2)\n                step = step + 1\n            \n            if self.x==self.capX:\n                self.rule(5)\n                step = step+1\n        return step \n\n    # Reverse the capacity of jugs\n    def reverseJugCapacity(self):\n        self.capX, self.capY = self.capY, self.capX\n    \n    # Solve  for both x,y and y,x conditions \n    def solve(self):\n        print(f'With JugXCapacity {self.capX} and JugYCapacity {self.capY}',end='\\\\n\\\\n\\\\n')\n        print(f'Total steps to solve : {self.pourRule()}',end='\\\\n\\\\n')\n        self.printPath()\n        print('*'*100)\n        print(f'With JugXCapacity {self.capX} and JugYCapacity {self.capY}',end='\\\\n\\\\n\\\\n')\n        self.reverseJugCapacity()\n        print(f'Total steps to solve : {self.pourRule()}',end='\\\\n\\\\n')\n        self.printPath()\n  `,\n  water_jug_pour_rule: `\n  # Solve using rules\n  def pourRule(self):\n      self.reset()\n      self.rule(2)\n      step = 1\n      while(1):\n          if(self.y==self.target or self.x==self.target):\n              break\n          \n          if(self.y < (self.capX-self.x)):\n              self.rule(9)\n          else:\n              self.rule(7)\n          \n          step=step+1\n          if(self.y==self.target or self.x==self.target):\n              break\n          \n          if self.y==0:\n              self.rule(2)\n              step = step + 1\n          \n          if self.x==self.capX:\n              self.rule(5)\n              step = step+1\n      return step \n  `,\n  water_jug_rules: `\n  def rule(self,x, d=0):\n    w.printVolume()\n    print('Rule {}'.format(x),end=' ')\n    # fill capX gallon jug completely\n    if(x==1):\n            if self.x<self.capX:\n                self.x=self.capX\n            print('Fill jugX completely')\n    # fill capY gallon jug completely\n    elif (x==2):\n            if self.y<self.capY:\n                self.y=self.capY\n            print('Fill jugY completely')\n    # pour some part from x jug\n    elif(x==3):\n            if self.x>0:\n                self.x= self.x - d\n            print('Pour Some part D from X jug')\n    # pour some part from y jug        \n    elif(x==4):\n            if self.y>0:\n                self.y = self.y - d\n            \n            print('Pour Some part D from Y jug')\n    # empty jug x        \n    elif(x==5):\n            if self.x>0:\n                self.x=0\n            print('Empty jugX')\n    # empty jug y        \n    elif(x==6):\n            if self.y>0:\n                self.y=0\n            print('Empty jugY')\n    # pour water from y jug to fill x jug        \n    elif(x==7):\n            if self.x+self.y < self.capX+self.capY:\n                self.y= self.y-(self.capX-self.x)\n                self.x = self.capX\n            print('Pour from jugY to fill jugX')\n    #pour water from x jug to fill y jug\n    elif(x==8):\n            if self.x+self.y < self.capX+self.capY:\n                self.x=self.x-(self.capY-self.y)\n                self.y = self.capY\n            print('Pour from jugX to fill jugY')\n    # pour all water from y jug to x jug\n    elif(x==9):\n            if self.x+self.y < self.capX:\n                self.x= self.x+self.y\n                self.y=0\n            print('Pour all from jugY to jugX')\n    #pour all water from x jug to y jug\n    elif(x==10):\n            if self.x+self.y < self.capY:\n                self.x=0\n                self.y=self.x+self.y     \n                print('Pour all from jugX to jugY')\n\n    w.printVolume()\n    print('---')\n    self.appendPath()\n  `,\n  water_jug_solution: `\n  w = WaterJug(5,3,4)\n  w.solve()\n  \n  OUTPUT:\n    With JugXCapacity 5 and JugYCapacity 3\n\n\n    [JugX=0, JugY=0]\n    Rule 2 Fill jugY completely\n    [JugX=0, JugY=3]\n    ---\n    [JugX=0, JugY=3]\n    Rule 9 Pour all from jugY to jugX\n    [JugX=3, JugY=0]\n    ---\n    [JugX=3, JugY=0]\n    Rule 2 Fill jugY completely\n    [JugX=3, JugY=3]\n    ---\n    [JugX=3, JugY=3]\n    Rule 7 Pour from jugY to fill jugX\n    [JugX=5, JugY=1]\n    ---\n    [JugX=5, JugY=1]\n    Rule 5 Empty jugX\n    [JugX=0, JugY=1]\n    ---\n    [JugX=0, JugY=1]\n    Rule 9 Pour all from jugY to jugX\n    [JugX=1, JugY=0]\n    ---\n    [JugX=1, JugY=0]\n    Rule 2 Fill jugY completely\n    [JugX=1, JugY=3]\n    ---\n    [JugX=1, JugY=3]\n    Rule 9 Pour all from jugY to jugX\n    [JugX=4, JugY=0]\n    ---\n    Total steps to solve : 8\n\n    [JugX:0, JugY:3]-> [JugX:3, JugY:0]-> [JugX:3, JugY:3]-> [JugX:5, JugY:1]->\n    [JugX:0, JugY:1]-> [JugX:1, JugY:0]-> [JugX:1, JugY:3]-> [JugX:4, JugY:0]\n    *****************************************************\n    With JugXCapacity 5 and JugYCapacity 3\n\n\n    [JugX=0, JugY=0]\n    Rule 2 Fill jugY completely\n    [JugX=0, JugY=5]\n    ---\n    [JugX=0, JugY=5]\n    Rule 7 Pour from jugY to fill jugX\n    [JugX=3, JugY=2]\n    ---\n    [JugX=3, JugY=2]\n    Rule 5 Empty jugX\n    [JugX=0, JugY=2]\n    ---\n    [JugX=0, JugY=2]\n    Rule 9 Pour all from jugY to jugX\n    [JugX=2, JugY=0]\n    ---\n    [JugX=2, JugY=0]\n    Rule 2 Fill jugY completely\n    [JugX=2, JugY=5]\n    ---\n    [JugX=2, JugY=5]\n    Rule 7 Pour from jugY to fill jugX\n    [JugX=3, JugY=4]\n    ---\n    Total steps to solve : 6\n\n    [JugX:0, JugY:5]->[JugX:3, JugY:2]->[JugX:0, JugY:2]\n    ->[JugX:2, JugY:0]->[JugX:2, JugY:5]->[JugX:3, JugY:4]\n\n  `,\n  a_star_search_grid_generation: `\n  const generateGrid = (numbeOfRows, numberOfColumns, value) => {\n    return range(numbeOfRows).map((x) =>\n      range(numberOfColumns).map((y) => ({\n        ...value,\n        x,\n        y,\n      }))\n    );\n  };\n  `,\n  a_star_search_coord_and_distance: `\n  const coordinatesToCheck = [\n    { y: 0, x: -1 },\n    { y: 1, x: -1 },\n    { y: 1, x: 0 },\n    { y: 1, x: 1 },\n    { y: 0, x: 1 },\n    { y: -1, x: 1 },\n    { y: -1, x: 0 },\n    { y: -1, x: -1 },\n  ];\n  \n  const getDistance = (a, b) => {\n    const colOffset = Math.abs(a.y - b.y);\n    const rowOffset = Math.abs(a.x - b.x);\n    const numberOfStraightSegments = Math.abs(colOffset - rowOffset);\n    const numberOfDiagonalSegments =\n      Math.max(colOffset, rowOffset) - numberOfStraightSegments;\n  \n    return numberOfStraightSegments * 10 + numberOfDiagonalSegments * 14; // 14 ~ 10 * sqrt(2)\n  };  \n  `,\n\n  a_star_search_path_calculation: `  \n  export const computePath = (mainGrid, start, end) => {\n    const gridLength = mainGrid.length;\n\n    let counter = 0;\n    let openList = [];\n    const grid = generateGrid(gridLength, gridLength, {\n      fCost: 0,\n      gCost: 0,\n      hCost: 0,\n      parent: undefined,\n      isClosed: false,\n      isPath: false,\n      counter: 0,\n      x: 0,\n      y: 0,\n    });\n    openList.push(grid[start.x][start.y]);\n\n    while (openList.length > 0) {\n      const currentCell = minBy(openList, (c) => c.fCost);\n\n      if (!currentCell) {\n        // no path found\n        return grid;\n      }\n\n      if (currentCell.x === end.x && currentCell.y === end.y) {\n        let curr = currentCell;\n\n        while (curr.parent) {\n          grid[curr.x][curr.y].isPath = true;\n          curr = curr.parent;\n        }\n\n        return grid;\n      }\n\n      remove(openList, (c) => c.x === currentCell.x && c.y === currentCell.y);\n      currentCell.isClosed = true;\n      // eslint-disable-next-line no-loop-func\n      coordinatesToCheck.forEach((coordinatesToCheck) => {\n        const { x, y } = {\n          x: currentCell.x + coordinatesToCheck.x,\n          y: currentCell.y + coordinatesToCheck.y,\n        };\n\n        if (\n          x < 0 ||\n          x >= gridLength ||\n          y < 0 ||\n          y >= gridLength ||\n          (start.x === x && start.y === y) ||\n          grid[x][y].isClosed ||\n          mainGrid[x][y].status === \"blocked\"\n        ) {\n          return;\n        }\n\n        const neighbourCell = grid[x][y];\n\n        const gCost = currentCell.gCost + getDistance(currentCell, neighbourCell);\n        let gCostIsBest = false;\n\n        if (!openList.find((c) => c.x === x && c.y === y)) {\n          gCostIsBest = true;\n          neighbourCell.hCost = getDistance(neighbourCell, end);\n          openList.push(neighbourCell);\n        } else if (gCost < neighbourCell.gCost) {\n          gCostIsBest = true;\n        }\n\n        if (gCostIsBest) {\n          neighbourCell.parent = currentCell;\n          neighbourCell.gCost = gCost;\n          neighbourCell.fCost = neighbourCell.gCost + neighbourCell.hCost;\n          counter = counter + 1;\n          neighbourCell.counter = counter;\n        }\n      });\n    }\n    // No path found\n    return grid;\n  };\n  `,\n  chatbot: `\n  import natural from \"natural\";\n\n  class Chatbot {  \n    constructor(name = \"Agent\") {\n      this.name = name;\n      this.questions = {};\n    }\n  \n    addQuestionsAnswer = (questions, answer) => {\n      let question;\n      for (question of questions) {\n        this.questions[question] = answer;\n      }\n    };\n  \n    //  stem words (fast but abstract words)\n    stemSentence = (sentence) => {\n      return natural.PorterStemmer.tokenizeAndStem(sentence);\n    };\n  \n    ask = (question) => {\n      question = question.toLowerCase().trim();\n      const questionWordList = this.stemSentence(question);\n      let index = 0;\n      let match = [];\n      //console.log(questionWordList);\n      let ques;\n      for (ques of Object.keys(this.questions)) {\n        ques = ques.toLowerCase().trim();\n        //console.log(ques);\n        const quesWordList = this.stemSentence(ques);\n        // console.log(quesWordList);\n        match.push(0);\n        let count = 0;\n        let word;\n        for (word of quesWordList) {\n          count += 1;\n          if (questionWordList.includes(word)) {\n            match[index] += 1;\n          }\n        }\n        match[index] = match[index] / Math.max(count, 1);\n        index += 1;\n        //  console.log(ques)\n        //  console.log(question)\n        // if (ques.toLowerCase().trim() === question) {\n        //   console.log(match);\n  \n        //   console.log(match.index(match.max));\n        //   return this.questions[ques];\n        // }\n      }\n      console.log(match);\n      const max = Math.max(...match);\n      console.log(max);\n      if (max >= 0.3) {\n        //  [match.index(max(match))]\n        const bestQuestionMatch = Object.keys(this.questions)[match.indexOf(max)];\n        return this.questions[bestQuestionMatch];\n      }\n      return \"I did not understand the question!\";\n    };\n  \n    listQuestions = () => {\n      var question;\n      let questionList = [];\n      for (question of Object.keys(this.questions)) {\n        // console.log(question);\n        questionList.push(question);\n      }\n      // console.log(questionList);\n      return questionList;\n    };\n  \n    initiateChat = () => {\n      // console.log(\"Chat with {this.name}\");\n      // console.log(\"Availabe questions for {this.name}\");\n      this.listQuestions();\n  \n      while (1) {\n        //var question = prompt(\"Enter question for {this.name} \\n\");\n        const question = \"Hi\";\n        if (\n          [\n            \"quit\",\n            \"exit\",\n            \"close\",\n            \"stop\",\n            \"end\",\n            \".\",\n            \"annihilate\",\n            \"disconnect\",\n          ].includes(question)\n        ) {\n          break;\n        }\n        // console.log(\"{this.ask(question)}\");\n      }\n    };\n  }   \n  `,\n  chatbot_stem: `\n  //  stem words (fast but abstract words)\n  stemSentence = (sentence) => {\n    return natural.PorterStemmer.tokenizeAndStem(sentence);\n  };\n  `,\n  chatbot_ask: `\n  ask = (question) => {\n    question = question.toLowerCase().trim();\n    const questionWordList = this.stemSentence(question);\n    let index = 0;\n    let match = [];\n    //console.log(questionWordList);\n    let ques;\n    for (ques of Object.keys(this.questions)) {\n      ques = ques.toLowerCase().trim();\n      //console.log(ques);\n      const quesWordList = this.stemSentence(ques);\n      // console.log(quesWordList);\n      match.push(0);\n      let count = 0;\n      let word;\n      for (word of quesWordList) {\n        count += 1;\n        if (questionWordList.includes(word)) {\n          match[index] += 1;\n        }\n      }\n      match[index] = match[index] / Math.max(count, 1);\n      index += 1;\n      //  console.log(ques)\n      //  console.log(question)\n      // if (ques.toLowerCase().trim() === question) {\n      //   console.log(match);\n\n      //   console.log(match.index(match.max));\n      //   return this.questions[ques];\n      // }\n    }\n    console.log(match);\n    const max = Math.max(...match);\n    console.log(max);\n    if (max >= 0.3) {\n      //  [match.index(max(match))]\n      const bestQuestionMatch = Object.keys(this.questions)[match.indexOf(max)];\n      return this.questions[bestQuestionMatch];\n    }\n    return \"I did not understand the question!\";\n  };\n  `,\n};\n","import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport clsx from 'clsx';\nimport withStyles from '../styles/withStyles';\nexport var styles = {\n  /* Styles applied to the root element. */\n  root: {\n    display: 'flex',\n    alignItems: 'center',\n    padding: 8\n  },\n\n  /* Styles applied to the root element if `disableSpacing={false}`. */\n  spacing: {\n    '& > :not(:first-child)': {\n      marginLeft: 8\n    }\n  }\n};\nvar CardActions = /*#__PURE__*/React.forwardRef(function CardActions(props, ref) {\n  var _props$disableSpacing = props.disableSpacing,\n      disableSpacing = _props$disableSpacing === void 0 ? false : _props$disableSpacing,\n      classes = props.classes,\n      className = props.className,\n      other = _objectWithoutProperties(props, [\"disableSpacing\", \"classes\", \"className\"]);\n\n  return /*#__PURE__*/React.createElement(\"div\", _extends({\n    className: clsx(classes.root, className, !disableSpacing && classes.spacing),\n    ref: ref\n  }, other));\n});\nprocess.env.NODE_ENV !== \"production\" ? CardActions.propTypes = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // |     To update them edit the d.ts file and run \"yarn proptypes\"     |\n  // ----------------------------------------------------------------------\n\n  /**\n   * The content of the component.\n   */\n  children: PropTypes.node,\n\n  /**\n   * Override or extend the styles applied to the component.\n   * See [CSS API](#css) below for more details.\n   */\n  classes: PropTypes.object,\n\n  /**\n   * @ignore\n   */\n  className: PropTypes.string,\n\n  /**\n   * If `true`, the actions do not have additional margin.\n   */\n  disableSpacing: PropTypes.bool\n} : void 0;\nexport default withStyles(styles, {\n  name: 'MuiCardActions'\n})(CardActions);","import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport clsx from 'clsx';\nimport capitalize from '../utils/capitalize';\nimport withStyles from '../styles/withStyles';\nimport { elementTypeAcceptingRef } from '@material-ui/utils';\nimport useIsFocusVisible from '../utils/useIsFocusVisible';\nimport useForkRef from '../utils/useForkRef';\nimport Typography from '../Typography';\nexport var styles = {\n  /* Styles applied to the root element. */\n  root: {},\n\n  /* Styles applied to the root element if `underline=\"none\"`. */\n  underlineNone: {\n    textDecoration: 'none'\n  },\n\n  /* Styles applied to the root element if `underline=\"hover\"`. */\n  underlineHover: {\n    textDecoration: 'none',\n    '&:hover': {\n      textDecoration: 'underline'\n    }\n  },\n\n  /* Styles applied to the root element if `underline=\"always\"`. */\n  underlineAlways: {\n    textDecoration: 'underline'\n  },\n  // Same reset as ButtonBase.root\n\n  /* Styles applied to the root element if `component=\"button\"`. */\n  button: {\n    position: 'relative',\n    WebkitTapHighlightColor: 'transparent',\n    backgroundColor: 'transparent',\n    // Reset default value\n    // We disable the focus ring for mouse, touch and keyboard users.\n    outline: 0,\n    border: 0,\n    margin: 0,\n    // Remove the margin in Safari\n    borderRadius: 0,\n    padding: 0,\n    // Remove the padding in Firefox\n    cursor: 'pointer',\n    userSelect: 'none',\n    verticalAlign: 'middle',\n    '-moz-appearance': 'none',\n    // Reset\n    '-webkit-appearance': 'none',\n    // Reset\n    '&::-moz-focus-inner': {\n      borderStyle: 'none' // Remove Firefox dotted outline.\n\n    },\n    '&$focusVisible': {\n      outline: 'auto'\n    }\n  },\n\n  /* Pseudo-class applied to the root element if the link is keyboard focused. */\n  focusVisible: {}\n};\nvar Link = /*#__PURE__*/React.forwardRef(function Link(props, ref) {\n  var classes = props.classes,\n      className = props.className,\n      _props$color = props.color,\n      color = _props$color === void 0 ? 'primary' : _props$color,\n      _props$component = props.component,\n      component = _props$component === void 0 ? 'a' : _props$component,\n      onBlur = props.onBlur,\n      onFocus = props.onFocus,\n      TypographyClasses = props.TypographyClasses,\n      _props$underline = props.underline,\n      underline = _props$underline === void 0 ? 'hover' : _props$underline,\n      _props$variant = props.variant,\n      variant = _props$variant === void 0 ? 'inherit' : _props$variant,\n      other = _objectWithoutProperties(props, [\"classes\", \"className\", \"color\", \"component\", \"onBlur\", \"onFocus\", \"TypographyClasses\", \"underline\", \"variant\"]);\n\n  var _useIsFocusVisible = useIsFocusVisible(),\n      isFocusVisible = _useIsFocusVisible.isFocusVisible,\n      onBlurVisible = _useIsFocusVisible.onBlurVisible,\n      focusVisibleRef = _useIsFocusVisible.ref;\n\n  var _React$useState = React.useState(false),\n      focusVisible = _React$useState[0],\n      setFocusVisible = _React$useState[1];\n\n  var handlerRef = useForkRef(ref, focusVisibleRef);\n\n  var handleBlur = function handleBlur(event) {\n    if (focusVisible) {\n      onBlurVisible();\n      setFocusVisible(false);\n    }\n\n    if (onBlur) {\n      onBlur(event);\n    }\n  };\n\n  var handleFocus = function handleFocus(event) {\n    if (isFocusVisible(event)) {\n      setFocusVisible(true);\n    }\n\n    if (onFocus) {\n      onFocus(event);\n    }\n  };\n\n  return /*#__PURE__*/React.createElement(Typography, _extends({\n    className: clsx(classes.root, classes[\"underline\".concat(capitalize(underline))], className, focusVisible && classes.focusVisible, component === 'button' && classes.button),\n    classes: TypographyClasses,\n    color: color,\n    component: component,\n    onBlur: handleBlur,\n    onFocus: handleFocus,\n    ref: handlerRef,\n    variant: variant\n  }, other));\n});\nprocess.env.NODE_ENV !== \"production\" ? Link.propTypes = {\n  /**\n   * The content of the link.\n   */\n  children: PropTypes.node.isRequired,\n\n  /**\n   * Override or extend the styles applied to the component.\n   * See [CSS API](#css) below for more details.\n   */\n  classes: PropTypes.object.isRequired,\n\n  /**\n   * @ignore\n   */\n  className: PropTypes.string,\n\n  /**\n   * The color of the link.\n   */\n  color: PropTypes.oneOf(['initial', 'inherit', 'primary', 'secondary', 'textPrimary', 'textSecondary', 'error']),\n\n  /**\n   * The component used for the root node.\n   * Either a string to use a HTML element or a component.\n   */\n  component: elementTypeAcceptingRef,\n\n  /**\n   * @ignore\n   */\n  onBlur: PropTypes.func,\n\n  /**\n   * @ignore\n   */\n  onFocus: PropTypes.func,\n\n  /**\n   * `classes` prop applied to the [`Typography`](/api/typography/) element.\n   */\n  TypographyClasses: PropTypes.object,\n\n  /**\n   * Controls when the link should have an underline.\n   */\n  underline: PropTypes.oneOf(['none', 'hover', 'always']),\n\n  /**\n   * Applies the theme typography styles.\n   */\n  variant: PropTypes.string\n} : void 0;\nexport default withStyles(styles, {\n  name: 'MuiLink'\n})(Link);","class Graph {\n  constructor() {\n    this.graph = [];\n    this.stack = [];\n    this.queue = [];\n  }\n  addEdge = (node, newNode) => {\n    if (this.graph[node] === undefined) this.graph[node] = [];\n    this.graph[node].push(newNode);\n  };\n\n  DFS = (key, rev = false) => {\n    let dfs = [];\n    this.stack.push(key);\n    while (1) {\n      if (this.stack.length === 0) {\n        // array empty or does not exist\n        break;\n      }\n      const popped = this.stack.pop();\n\n      dfs.push(popped);\n      if (this.graph[popped] === undefined) {\n      } else {\n        let childData;\n        if (rev) childData = this.graph[popped].slice().reverse();\n        else childData = this.graph[popped];\n        for (let i of childData) {\n          this.stack.push(i);\n        }\n      }\n    }\n    return dfs;\n  };\n  BFS = (key) => {\n    this.queue.push(key);\n    let bfs = [];\n    while (1) {\n      if (this.queue.length === 0) {\n        // array empty or does not exist\n        break;\n      }\n      const popped = this.queue.shift();\n      bfs.push(popped);\n\n      if (this.graph[popped] === undefined) {\n      } else {\n        const childData = this.graph[popped];\n        for (let i of childData) {\n          this.queue.push(i);\n        }\n      }\n    }\n    return bfs;\n  };\n}\nexport default Graph;\n","import React from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport {\n  changeHighlightedNode,\n  selectHighlightedNode,\n} from \"../features/graph/graphSlice\";\n\nconst GraphNode = (props) => {\n  const { name, index, x_position, y_position } = props;\n  const dispatch = useDispatch();\n  const highlightedNode = useSelector(selectHighlightedNode);\n  let strokeColor = \"black\";\n  if (highlightedNode === index) strokeColor = \"green\";\n  return (\n    <>\n      <svg\n        x={x_position}\n        y={y_position}\n        onClick={() => dispatch(changeHighlightedNode({ index: index }))}\n      >\n        <circle\n          cx=\"30\"\n          cy=\"30\"\n          r=\"20\"\n          stroke={strokeColor}\n          strokeWidth=\"3\"\n          fill=\"red\"\n          fillOpacity=\"0.5\"\n        />\n        <text textAnchor=\"middle\" x=\"30\" y=\"30\">\n          {name}\n        </text>\n      </svg>\n    </>\n  );\n};\nexport default GraphNode;\n","import React from \"react\";\nimport GraphNode from \"./GraphNode\";\nimport { useSelector } from \"react-redux\";\nimport { selectGraph } from \"../features/graph/graphSlice\";\n\nconst GraphTree = (props) => {\n  const {\n    parentName,\n    parentIndex,\n    x_position = 0,\n    y_position = 0,\n    height,\n    width,\n  } = props;\n  const graph = useSelector(selectGraph);\n  let renderChildrenList = false;\n\n  const countChildren = (object) => {\n    // console.log(\"Children\", object);\n    if (typeof object === \"undefined\") return 0;\n    let count = 0;\n    for (let key of Object.keys(object)) {\n      count++;\n      count += countChildren(graph[object[key]]);\n    }\n    return count;\n  };\n\n  const childObject = graph[parentName];\n\n  let len = 0;\n  let childList = [];\n  len = countChildren(childObject);\n\n  if (typeof childObject !== \"undefined\") {\n    renderChildrenList = true;\n\n    for (let key of Object.keys(childObject)) {\n      childList.push([key, childObject[key]]);\n    }\n  }\n\n  // console.log(\"Maximum children \" + parentName, len);\n\n  let varSpacing = -len * 25;\n  return (\n    <svg\n      x_position={x_position}\n      y_position={y_position}\n      width={width}\n      height={height}\n    >\n      <GraphNode\n        x_position={parentIndex === 0 ? width / 2 : x_position}\n        y_position={y_position}\n        name={parentName}\n        index={parentIndex}\n      />\n\n      {renderChildrenList\n        ? childList.map((name, index) => {\n            varSpacing += len * 25;\n            return typeof graph[name[1]] !== \"undefined\" ? (\n              <GraphTree\n                x_position={x_position + varSpacing}\n                y_position={y_position + 100}\n                width={width}\n                height={height}\n                key={index}\n                parentName={name[1]}\n                parentIndex={name[0]}\n              />\n            ) : (\n              <GraphTree\n                x_position={x_position + varSpacing}\n                y_position={y_position + 100}\n                key={index}\n                parentName={name[1]}\n                parentIndex={name[0]}\n              />\n            );\n          })\n        : null}\n    </svg>\n  );\n};\nexport default GraphTree;\n","import React, { useState } from \"react\";\nimport { useSelector, useDispatch } from \"react-redux\";\nimport {\n  addNode,\n  showDFS,\n  showBFS,\n  selectNode,\n  selectHighlightedNode,\n  selectBFSPath,\n  selectDFSPath,\n  resetGraph,\n} from \"./graphSlice\";\n\nimport {\n  Card,\n  CardContent,\n  Typography,\n  Grid,\n  CardActions,\n  Button,\n  TextField,\n} from \"@material-ui/core\";\nimport Graph from \"./GraphClass\";\nimport GraphTree from \"../../components/GraphTree\";\n\nlet g = new Graph();\n\nconst GraphComponent = () => {\n  const nodeList = useSelector(selectNode);\n  const highlightedNode = useSelector(selectHighlightedNode);\n\n  const bfs = useSelector(selectBFSPath);\n  const dfs = useSelector(selectDFSPath);\n  const dispatch = useDispatch();\n  const [nodeName, setNodeName] = useState(\"\");\n\n  const handleNewNodeSubmit = () => {\n    if (nodeList.includes(nodeName)) return;\n    dispatch(addNode({ name: nodeName || \"Node\" }));\n    if (typeof nodeList[highlightedNode] !== \"undefined\")\n      g.addEdge(nodeList[highlightedNode], nodeName);\n    setNodeName(\"\");\n  };\n\n  const handleShowDFS = () => {\n    const dfs = g.DFS(nodeList[highlightedNode], true);\n    dispatch(showDFS({ DFSPath: dfs }));\n  };\n\n  const handleShowBFS = () => {\n    const bfs = g.BFS(nodeList[highlightedNode]);\n    dispatch(showBFS({ BFSPath: bfs }));\n  };\n\n  return (\n    <Grid direction=\"column\" container spacing={2}>\n      <Grid item>\n        <Card>\n          <CardContent>\n            <Grid container>\n              <Grid item>\n                <Typography variant=\"h5\">Breadth First Search:</Typography>\n                <Typography>\n                  {bfs.length !== 0\n                    ? bfs.map((data) => {\n                        if (data === bfs[bfs.length - 1]) return data;\n                        else return data + \"->\";\n                      })\n                    : \"(BFS Path)\"}\n                </Typography>\n                <Typography variant=\"h5\">Depth First Search:</Typography>\n                <Typography>\n                  {dfs.length !== 0\n                    ? dfs.map((data) => {\n                        if (data === dfs[dfs.length - 1]) return data;\n                        else return data + \"->\";\n                      })\n                    : \"(DFS Path)\"}\n                </Typography>\n                <Typography>Enter node name to draw tree graph.</Typography>\n              </Grid>\n            </Grid>\n          </CardContent>\n          <CardActions>\n            <TextField\n              label=\"Node Name\"\n              plaardceholder=\"Node\"\n              variant=\"outlined\"\n              aria-label=\"Node name\"\n              value={nodeName}\n              onChange={(e) => setNodeName(e.target.value)}\n              onKeyPress={(e) => {\n                if (e.key === \"Enter\") handleNewNodeSubmit();\n              }}\n            />\n            <Button variant=\"outlined\" onClick={handleNewNodeSubmit}>\n              Add node\n            </Button>\n            <Button variant=\"outlined\" onClick={handleShowDFS}>\n              Show DFS\n            </Button>\n            <Button variant=\"outlined\" onClick={handleShowBFS}>\n              Show BFS\n            </Button>\n            <Button\n              variant=\"outlined\"\n              onClick={() => {\n                g = new Graph();\n                dispatch(resetGraph());\n              }}\n            >\n              Reset Tree Graph\n            </Button>\n          </CardActions>\n        </Card>\n      </Grid>\n\n      <Grid item>\n        <Card>\n          <CardContent>\n            <Typography variant=\"h4\" align=\"center\">\n              Tree Graph\n            </Typography>\n            {nodeList.length !== 0 ? (\n              <GraphTree\n                width={window.innerWidth / 2 + window.innerWidth / 4}\n                height={600}\n                parentName={nodeList[0]}\n                parentIndex={0}\n              />\n            ) : null}\n          </CardContent>\n        </Card>\n      </Grid>\n    </Grid>\n  );\n};\nexport default React.memo(GraphComponent);\n","import React from \"react\";\nimport {\n  Grid,\n  Typography,\n  Card,\n  CardContent,\n  Link,\n  CardHeader,\n} from \"@material-ui/core\";\nimport GraphComponent from \"../../features/graph/Graph\";\nimport CodeBlock from \"../../components/CodeBlock\";\nimport { snippets } from \"../../snippets\";\n\nconst snip = `   A dictionary/object is used to store list of its children to maintain relation between each node and its childrens. i.e  {'parentNode': [children]}.\nTo add node, either children are added to existing parent key or a new parent key is created to store children for that node. \nA function addEdge(node, newNode) takes two input 'node'i.e. parent Node and 'newNode'i.e. to be added child node.\n`;\nconst Lab2 = () => {\n  const tabNameList = [\"BFS\", \"DFS\", \"Graph Class\"];\n  const tabCodeSnippetList = [snippets.bfs, snippets.dfs, snippets.graphClass];\n  // console.log(g.graph);\n  return (\n    <Grid item container direction=\"column\" spacing={2}>\n      <Grid item>\n        <Card>\n          <CardHeader title=\"DFS and BFS\" />\n          <CardContent>\n            <Typography variant=\"body1\">\n              Each node can be selected. A green highlight is around currently\n              selected node.\n            </Typography>\n            <Typography variant=\"body1\">\n              'Add node' adds child node to the currently selected node.\n            </Typography>\n            <Typography variant=\"body1\">\n              Show DFS and Show BFS calculates path from currently selected node\n              to all its leaf nodes.\n            </Typography>\n            <Typography variant=\"body1\">\n              Two Nodes cannot have the same name.\n            </Typography>\n            <Typography variant=\"body2\">\n              *Capable of displaying Tree of Depth 6 nodes with each node having\n              2 children on a full screen\n            </Typography>\n          </CardContent>\n        </Card>\n      </Grid>\n      <Grid item container>\n        <GraphComponent />\n      </Grid>\n      <Grid item xs={12}>\n        <CodeBlock\n          tabNameList={tabNameList}\n          tabCodeSnippetList={tabCodeSnippetList}\n          language=\"javascript\"\n        />\n      </Grid>\n      <Grid item>\n        <Card>\n          <CardHeader title=\"Adding Node\" />\n          <CardContent>\n            <Typography>{snip}</Typography>\n          </CardContent>\n        </Card>\n      </Grid>\n      <Grid item>\n        <Card>\n          <CardHeader title=\"Github Link\" />\n          <CardContent>\n            <Link\n              color=\"secondary\"\n              variant=\"body2\"\n              href=\"https://github.com/B10prajapati/AI_LAB\"\n            >\n              {\"Github Link\"}\n            </Link>\n          </CardContent>\n        </Card>\n      </Grid>\n    </Grid>\n  );\n};\nexport default Lab2;\n"],"sourceRoot":""}