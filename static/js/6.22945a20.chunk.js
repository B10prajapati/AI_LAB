(this.webpackJsonpai_lab=this.webpackJsonpai_lab||[]).push([[6],{201:function(e,n,t){"use strict";var a=t(73),s=t(234),l=t(720),r=t(734),o=t(721),i=t(746),u=t(736),c=t(0),f=t.n(c),p=t(744),g=t(737);function d(e){var n=e.children,t=e.value,a=e.index,l=Object(s.a)(e,["children","value","index"]);return f.a.createElement("div",Object.assign({role:"tabpanel",hidden:t!==a,id:"simple-tabpanel-".concat(a),"aria-labelledby":"simple-tab-".concat(a)},l),t===a&&f.a.createElement(f.a.Fragment,null," ",n," "))}n.a=function(e){var n=f.a.useState(0),t=Object(a.a)(n,2),s=t[0],c=t[1],h=e.tabNameList,m=e.tabCodeSnippetList,y=e.language;return f.a.createElement(l.a,null,f.a.createElement(r.a,{title:"Code"}),f.a.createElement(o.a,null,f.a.createElement(i.a,{value:s,onChange:function(e,n){c(n)},"aria-label":"Tree Graph"},h.map((function(e,n){return f.a.createElement(u.a,Object.assign({key:n,label:e},function(e){return{id:"simple-tab-".concat(e),"aria-controls":"simple-tabpanel-".concat(e)}}(n)))}))),m.map((function(e,n){return f.a.createElement(d,{value:s,key:n,index:n},f.a.createElement(p.a,{language:y,style:g.a,lineProps:{style:{wordBreak:"break-all",whiteSpace:"pre-wrap"}},wrapLines:!0},e))}))))}},202:function(e,n,t){"use strict";t.d(n,"a",(function(){return a}));var a={dfs:"\n  DFS = (key, rev = false) => {\n    let dfs = [];\n    this.stack.push(key);\n    while (1) {\n      if (this.stack.length === 0) {\n        // array empty or does not exist\n        break;\n      }\n      const popped = this.stack.pop();\n\n      dfs.push(popped);\n      if (this.graph[popped] === undefined) {\n      } else {\n        let childData;\n        if (rev) childData = this.graph[popped].slice().reverse();\n        else childData = this.graph[popped];\n        for (let i of childData) {\n          this.stack.push(i);\n        }\n      }\n    }\n    return dfs;\n  };",bfs:"\n  BFS = (key) => {\n    this.queue.push(key);\n    let bfs = [];\n    while (1) {\n      if (this.queue.length === 0) {\n        // array empty or does not exist\n        break;\n      }\n      const popped = this.queue.shift();\n      bfs.push(popped);\n\n      if (this.graph[popped] === undefined) {\n      } else {\n        const childData = this.graph[popped];\n        for (let i of childData) {\n          this.queue.push(i);\n        }\n      }\n    }\n    return bfs;\n  };",graphClass:"\n  class Graph {\n    constructor() {\n      this.graph = [];\n      this.stack = [];\n      this.queue = [];\n    }\n    addEdge = (node, newNode) => {\n      if (this.graph[node] === undefined) this.graph[node] = [];\n      this.graph[node].push(newNode);\n    };\n  \n    DFS = (key, rev = false) => {\n      let dfs = [];\n      this.stack.push(key);\n      while (1) {\n        if (this.stack.length === 0) {\n          // array empty or does not exist\n          break;\n        }\n        const popped = this.stack.pop();\n  \n        dfs.push(popped);\n        if (this.graph[popped] === undefined) {\n        } else {\n          let childData;\n          if (rev) childData = this.graph[popped].slice().reverse();\n          else childData = this.graph[popped];\n          for (let i of childData) {\n            this.stack.push(i);\n          }\n        }\n      }\n      return dfs;\n    };\n    BFS = (key) => {\n      this.queue.push(key);\n      let bfs = [];\n      while (1) {\n        if (this.queue.length === 0) {\n          // array empty or does not exist\n          break;\n        }\n        const popped = this.queue.shift();\n        bfs.push(popped);\n  \n        if (this.graph[popped] === undefined) {\n        } else {\n          const childData = this.graph[popped];\n          for (let i of childData) {\n            this.queue.push(i);\n          }\n        }\n      }\n      return bfs;\n    };\n  }\n  ",water_jug:"\n  class WaterJug():\n    def __init__(self,x,y,target):\n        self.capX = x\n        self.capY = y\n        self.x = 0\n        self.y = 0\n        self.targe,end='\\n\\n\\n't = target\n        self.path = []\n        \n    def rule(self,x, d=0):\n        w.printVolume()\n        print('Rule {}'.format(x),end=' ')\n        # fill capX gallon jug completely\n        if(x==1):\n                if self.x<self.capX:\n                    self.x=self.capX\n                print('Fill jugX completely')\n        # fill capY gallon jug completely\n        elif (x==2):\n                if self.y<self.capY:\n                    self.y=self.capY\n                print('Fill jugY completely')\n        # pour some part from x jug\n        elif(x==3):\n                if self.x>0:\n                    self.x= self.x - d\n                print('Pour Some part D from X jug')\n        # pour some part from y jug        \n        elif(x==4):\n                if self.y>0:\n                    self.y = self.y - d\n                \n                print('Pour Some part D from Y jug')\n        # empty jug x        \n        elif(x==5):\n                if self.x>0:\n                    self.x=0\n                print('Empty jugX')\n        # empty jug y        \n        elif(x==6):\n                if self.y>0:\n                    self.y=0\n                print('Empty jugY')\n        # pour water from y jug to fill x jug        \n        elif(x==7):\n                if self.x+self.y < self.capX+self.capY:\n                    self.y= self.y-(self.capX-self.x)\n                    self.x = self.capX\n                print('Pour from jugY to fill jugX')\n        #pour water from x jug to fill y jug\n        elif(x==8):\n                if self.x+self.y < self.capX+self.capY:\n                    self.x=self.x-(self.capY-self.y)\n                    self.y = self.capY\n                print('Pour from jugX to fill jugY')\n        # pour all water from y jug to x jug\n        elif(x==9):\n                if self.x+self.y < self.capX:\n                    self.x= self.x+self.y\n                    self.y=0\n                print('Pour all from jugY to jugX')\n        #pour all water from x jug to y jug\n        elif(x==10):\n                if self.x+self.y < self.capY:\n                    self.x=0\n                    self.y=self.x+self.y     \n                    print('Pour all from jugX to jugY')\n\n        w.printVolume()\n        print('---')\n        self.appendPath()\n             \n    def printVolume(self):\n        print('[JugX={}, JugY={}]'.format(self.x, self.y))\n    \n    # print each state leading upto solution\n    def printPath(self):\n        for state in self.path:\n            if state==self.path[-1]:\n                print(f'[JugX:{state[0]}, JugY:{state[1]}]')\n                continue\n            print(f'[JugX:{state[0]}, JugY:{state[1]}]', end='->')\n    \n    # add new state generated to path\n    def appendPath(self):\n        self.path.append([self.x, self.y])\n    \n    def reset(self):\n        self.x=0\n        self.y=0\n        self.path=[]\n        \n    def pour(self): \n        self.reset()\n        yJug= self.capY\n        xJug=0\n#         self.rule(2)\n        step = 1\n        while ((yJug  is not self.target) and (xJug is not self.target)): \n            print('({},{})'.format(xJug, yJug))\n            \n\n            if(yJug < (self.capX-xJug)):\n                temp = yJug\n#                 self.rule(9)\n            else:\n                temp = (self.capX-xJug)\n#                 self.rule(7)\n            xJug = xJug + temp\n            yJug = yJug - temp\n\n#             temp = min(yJug, self.capX-xJug) \n#             xJug = xJug + temp \n#             yJug = yJug - temp \n\n            print('({},{})'.format(xJug, yJug))\n\n            step =  step + 1\n            if ((yJug == self.target) or (xJug == self.target)): \n                break\n\n            if yJug == 0: \n                yJug = self.capY\n#                 self.rule(2)\n                step =  step + 1\n\n            if xJug == self.capX: \n                xJug = 0\n#                 self.rule(5)\n                step =  step + 1\n    \n    # Solve using rules\n    def pourRule(self):\n        self.reset()\n        self.rule(2)\n        step = 1\n        while(1):\n            if(self.y==self.target or self.x==self.target):\n                break\n            \n            if(self.y < (self.capX-self.x)):\n                self.rule(9)\n            else:\n                self.rule(7)\n            \n            step=step+1\n            if(self.y==self.target or self.x==self.target):\n                break\n            \n            if self.y==0:\n                self.rule(2)\n                step = step + 1\n            \n            if self.x==self.capX:\n                self.rule(5)\n                step = step+1\n        return step \n\n    # Reverse the capacity of jugs\n    def reverseJugCapacity(self):\n        self.capX, self.capY = self.capY, self.capX\n    \n    # Solve  for both x,y and y,x conditions \n    def solve(self):\n        print(f'With JugXCapacity {self.capX} and JugYCapacity {self.capY}',end='\\n\\n\\n')\n        print(f'Total steps to solve : {self.pourRule()}',end='\\n\\n')\n        self.printPath()\n        print('*'*100)\n        print(f'With JugXCapacity {self.capX} and JugYCapacity {self.capY}',end='\\n\\n\\n')\n        self.reverseJugCapacity()\n        print(f'Total steps to solve : {self.pourRule()}',end='\\n\\n')\n        self.printPath()\n  ",water_jug_pour_rule:"\n  # Solve using rules\n  def pourRule(self):\n      self.reset()\n      self.rule(2)\n      step = 1\n      while(1):\n          if(self.y==self.target or self.x==self.target):\n              break\n          \n          if(self.y < (self.capX-self.x)):\n              self.rule(9)\n          else:\n              self.rule(7)\n          \n          step=step+1\n          if(self.y==self.target or self.x==self.target):\n              break\n          \n          if self.y==0:\n              self.rule(2)\n              step = step + 1\n          \n          if self.x==self.capX:\n              self.rule(5)\n              step = step+1\n      return step \n  ",water_jug_rules:"\n  def rule(self,x, d=0):\n    w.printVolume()\n    print('Rule {}'.format(x),end=' ')\n    # fill capX gallon jug completely\n    if(x==1):\n            if self.x<self.capX:\n                self.x=self.capX\n            print('Fill jugX completely')\n    # fill capY gallon jug completely\n    elif (x==2):\n            if self.y<self.capY:\n                self.y=self.capY\n            print('Fill jugY completely')\n    # pour some part from x jug\n    elif(x==3):\n            if self.x>0:\n                self.x= self.x - d\n            print('Pour Some part D from X jug')\n    # pour some part from y jug        \n    elif(x==4):\n            if self.y>0:\n                self.y = self.y - d\n            \n            print('Pour Some part D from Y jug')\n    # empty jug x        \n    elif(x==5):\n            if self.x>0:\n                self.x=0\n            print('Empty jugX')\n    # empty jug y        \n    elif(x==6):\n            if self.y>0:\n                self.y=0\n            print('Empty jugY')\n    # pour water from y jug to fill x jug        \n    elif(x==7):\n            if self.x+self.y < self.capX+self.capY:\n                self.y= self.y-(self.capX-self.x)\n                self.x = self.capX\n            print('Pour from jugY to fill jugX')\n    #pour water from x jug to fill y jug\n    elif(x==8):\n            if self.x+self.y < self.capX+self.capY:\n                self.x=self.x-(self.capY-self.y)\n                self.y = self.capY\n            print('Pour from jugX to fill jugY')\n    # pour all water from y jug to x jug\n    elif(x==9):\n            if self.x+self.y < self.capX:\n                self.x= self.x+self.y\n                self.y=0\n            print('Pour all from jugY to jugX')\n    #pour all water from x jug to y jug\n    elif(x==10):\n            if self.x+self.y < self.capY:\n                self.x=0\n                self.y=self.x+self.y     \n                print('Pour all from jugX to jugY')\n\n    w.printVolume()\n    print('---')\n    self.appendPath()\n  ",water_jug_solution:"\n  w = WaterJug(5,3,4)\n  w.solve()\n  \n  OUTPUT:\n    With JugXCapacity 5 and JugYCapacity 3\n\n\n    [JugX=0, JugY=0]\n    Rule 2 Fill jugY completely\n    [JugX=0, JugY=3]\n    ---\n    [JugX=0, JugY=3]\n    Rule 9 Pour all from jugY to jugX\n    [JugX=3, JugY=0]\n    ---\n    [JugX=3, JugY=0]\n    Rule 2 Fill jugY completely\n    [JugX=3, JugY=3]\n    ---\n    [JugX=3, JugY=3]\n    Rule 7 Pour from jugY to fill jugX\n    [JugX=5, JugY=1]\n    ---\n    [JugX=5, JugY=1]\n    Rule 5 Empty jugX\n    [JugX=0, JugY=1]\n    ---\n    [JugX=0, JugY=1]\n    Rule 9 Pour all from jugY to jugX\n    [JugX=1, JugY=0]\n    ---\n    [JugX=1, JugY=0]\n    Rule 2 Fill jugY completely\n    [JugX=1, JugY=3]\n    ---\n    [JugX=1, JugY=3]\n    Rule 9 Pour all from jugY to jugX\n    [JugX=4, JugY=0]\n    ---\n    Total steps to solve : 8\n\n    [JugX:0, JugY:3]-> [JugX:3, JugY:0]-> [JugX:3, JugY:3]-> [JugX:5, JugY:1]->\n    [JugX:0, JugY:1]-> [JugX:1, JugY:0]-> [JugX:1, JugY:3]-> [JugX:4, JugY:0]\n    *****************************************************\n    With JugXCapacity 5 and JugYCapacity 3\n\n\n    [JugX=0, JugY=0]\n    Rule 2 Fill jugY completely\n    [JugX=0, JugY=5]\n    ---\n    [JugX=0, JugY=5]\n    Rule 7 Pour from jugY to fill jugX\n    [JugX=3, JugY=2]\n    ---\n    [JugX=3, JugY=2]\n    Rule 5 Empty jugX\n    [JugX=0, JugY=2]\n    ---\n    [JugX=0, JugY=2]\n    Rule 9 Pour all from jugY to jugX\n    [JugX=2, JugY=0]\n    ---\n    [JugX=2, JugY=0]\n    Rule 2 Fill jugY completely\n    [JugX=2, JugY=5]\n    ---\n    [JugX=2, JugY=5]\n    Rule 7 Pour from jugY to fill jugX\n    [JugX=3, JugY=4]\n    ---\n    Total steps to solve : 6\n\n    [JugX:0, JugY:5]->[JugX:3, JugY:2]->[JugX:0, JugY:2]\n    ->[JugX:2, JugY:0]->[JugX:2, JugY:5]->[JugX:3, JugY:4]\n\n  ",a_star_search_grid_generation:"\n  const generateGrid = (numbeOfRows, numberOfColumns, value) => {\n    return range(numbeOfRows).map((x) =>\n      range(numberOfColumns).map((y) => ({\n        ...value,\n        x,\n        y,\n      }))\n    );\n  };\n  ",a_star_search_coord_and_distance:"\n  const coordinatesToCheck = [\n    { y: 0, x: -1 },\n    { y: 1, x: -1 },\n    { y: 1, x: 0 },\n    { y: 1, x: 1 },\n    { y: 0, x: 1 },\n    { y: -1, x: 1 },\n    { y: -1, x: 0 },\n    { y: -1, x: -1 },\n  ];\n  \n  const getDistance = (a, b) => {\n    const colOffset = Math.abs(a.y - b.y);\n    const rowOffset = Math.abs(a.x - b.x);\n    const numberOfStraightSegments = Math.abs(colOffset - rowOffset);\n    const numberOfDiagonalSegments =\n      Math.max(colOffset, rowOffset) - numberOfStraightSegments;\n  \n    return numberOfStraightSegments * 10 + numberOfDiagonalSegments * 14; // 14 ~ 10 * sqrt(2)\n  };  \n  ",a_star_search_path_calculation:'  \n  export const computePath = (mainGrid, start, end) => {\n    const gridLength = mainGrid.length;\n\n    let counter = 0;\n    let openList = [];\n    const grid = generateGrid(gridLength, gridLength, {\n      fCost: 0,\n      gCost: 0,\n      hCost: 0,\n      parent: undefined,\n      isClosed: false,\n      isPath: false,\n      counter: 0,\n      x: 0,\n      y: 0,\n    });\n    openList.push(grid[start.x][start.y]);\n\n    while (openList.length > 0) {\n      const currentCell = minBy(openList, (c) => c.fCost);\n\n      if (!currentCell) {\n        // no path found\n        return grid;\n      }\n\n      if (currentCell.x === end.x && currentCell.y === end.y) {\n        let curr = currentCell;\n\n        while (curr.parent) {\n          grid[curr.x][curr.y].isPath = true;\n          curr = curr.parent;\n        }\n\n        return grid;\n      }\n\n      remove(openList, (c) => c.x === currentCell.x && c.y === currentCell.y);\n      currentCell.isClosed = true;\n      // eslint-disable-next-line no-loop-func\n      coordinatesToCheck.forEach((coordinatesToCheck) => {\n        const { x, y } = {\n          x: currentCell.x + coordinatesToCheck.x,\n          y: currentCell.y + coordinatesToCheck.y,\n        };\n\n        if (\n          x < 0 ||\n          x >= gridLength ||\n          y < 0 ||\n          y >= gridLength ||\n          (start.x === x && start.y === y) ||\n          grid[x][y].isClosed ||\n          mainGrid[x][y].status === "blocked"\n        ) {\n          return;\n        }\n\n        const neighbourCell = grid[x][y];\n\n        const gCost = currentCell.gCost + getDistance(currentCell, neighbourCell);\n        let gCostIsBest = false;\n\n        if (!openList.find((c) => c.x === x && c.y === y)) {\n          gCostIsBest = true;\n          neighbourCell.hCost = getDistance(neighbourCell, end);\n          openList.push(neighbourCell);\n        } else if (gCost < neighbourCell.gCost) {\n          gCostIsBest = true;\n        }\n\n        if (gCostIsBest) {\n          neighbourCell.parent = currentCell;\n          neighbourCell.gCost = gCost;\n          neighbourCell.fCost = neighbourCell.gCost + neighbourCell.hCost;\n          counter = counter + 1;\n          neighbourCell.counter = counter;\n        }\n      });\n    }\n    // No path found\n    return grid;\n  };\n  ',chatbot:'\n  import natural from "natural";\n\n  class Chatbot {  \n    constructor(name = "Agent") {\n      this.name = name;\n      this.questions = {};\n    }\n  \n    addQuestionsAnswer = (questions, answer) => {\n      let question;\n      for (question of questions) {\n        this.questions[question] = answer;\n      }\n    };\n  \n    //  stem words (fast but abstract words)\n    stemSentence = (sentence) => {\n      return natural.PorterStemmer.tokenizeAndStem(sentence);\n    };\n  \n    ask = (question) => {\n      question = question.toLowerCase().trim();\n      const questionWordList = this.stemSentence(question);\n      let index = 0;\n      let match = [];\n      //console.log(questionWordList);\n      let ques;\n      for (ques of Object.keys(this.questions)) {\n        ques = ques.toLowerCase().trim();\n        //console.log(ques);\n        const quesWordList = this.stemSentence(ques);\n        // console.log(quesWordList);\n        match.push(0);\n        let count = 0;\n        let word;\n        for (word of quesWordList) {\n          count += 1;\n          if (questionWordList.includes(word)) {\n            match[index] += 1;\n          }\n        }\n        match[index] = match[index] / Math.max(count, 1);\n        index += 1;\n        //  console.log(ques)\n        //  console.log(question)\n        // if (ques.toLowerCase().trim() === question) {\n        //   console.log(match);\n  \n        //   console.log(match.index(match.max));\n        //   return this.questions[ques];\n        // }\n      }\n      console.log(match);\n      const max = Math.max(...match);\n      console.log(max);\n      if (max >= 0.3) {\n        //  [match.index(max(match))]\n        const bestQuestionMatch = Object.keys(this.questions)[match.indexOf(max)];\n        return this.questions[bestQuestionMatch];\n      }\n      return "I did not understand the question!";\n    };\n  \n    listQuestions = () => {\n      var question;\n      let questionList = [];\n      for (question of Object.keys(this.questions)) {\n        // console.log(question);\n        questionList.push(question);\n      }\n      // console.log(questionList);\n      return questionList;\n    };\n  \n    initiateChat = () => {\n      // console.log("Chat with {this.name}");\n      // console.log("Availabe questions for {this.name}");\n      this.listQuestions();\n  \n      while (1) {\n        //var question = prompt("Enter question for {this.name} \n");\n        const question = "Hi";\n        if (\n          [\n            "quit",\n            "exit",\n            "close",\n            "stop",\n            "end",\n            ".",\n            "annihilate",\n            "disconnect",\n          ].includes(question)\n        ) {\n          break;\n        }\n        // console.log("{this.ask(question)}");\n      }\n    };\n  }   \n  ',chatbot_stem:"\n  //  stem words (fast but abstract words)\n  stemSentence = (sentence) => {\n    return natural.PorterStemmer.tokenizeAndStem(sentence);\n  };\n  ",chatbot_ask:'\n  ask = (question) => {\n    question = question.toLowerCase().trim();\n    const questionWordList = this.stemSentence(question);\n    let index = 0;\n    let match = [];\n    //console.log(questionWordList);\n    let ques;\n    for (ques of Object.keys(this.questions)) {\n      ques = ques.toLowerCase().trim();\n      //console.log(ques);\n      const quesWordList = this.stemSentence(ques);\n      // console.log(quesWordList);\n      match.push(0);\n      let count = 0;\n      let word;\n      for (word of quesWordList) {\n        count += 1;\n        if (questionWordList.includes(word)) {\n          match[index] += 1;\n        }\n      }\n      match[index] = match[index] / Math.max(count, 1);\n      index += 1;\n      //  console.log(ques)\n      //  console.log(question)\n      // if (ques.toLowerCase().trim() === question) {\n      //   console.log(match);\n\n      //   console.log(match.index(match.max));\n      //   return this.questions[ques];\n      // }\n    }\n    console.log(match);\n    const max = Math.max(...match);\n    console.log(max);\n    if (max >= 0.3) {\n      //  [match.index(max(match))]\n      const bestQuestionMatch = Object.keys(this.questions)[match.indexOf(max)];\n      return this.questions[bestQuestionMatch];\n    }\n    return "I did not understand the question!";\n  };\n  '}},335:function(e,n,t){"use strict";var a=t(1),s=t(2),l=t(0),r=(t(3),t(4)),o=t(5),i=l.forwardRef((function(e,n){var t=e.disableSpacing,o=void 0!==t&&t,i=e.classes,u=e.className,c=Object(s.a)(e,["disableSpacing","classes","className"]);return l.createElement("div",Object(a.a)({className:Object(r.a)(i.root,u,!o&&i.spacing),ref:n},c))}));n.a=Object(o.a)({root:{display:"flex",alignItems:"center",padding:8},spacing:{"& > :not(:first-child)":{marginLeft:8}}},{name:"MuiCardActions"})(i)},590:function(e,n,t){"use strict";var a=t(1),s=t(2),l=t(0),r=(t(3),t(4)),o=t(10),i=t(5),u=t(76),c=t(12),f=t(63),p=l.forwardRef((function(e,n){var t=e.classes,i=e.className,p=e.color,g=void 0===p?"primary":p,d=e.component,h=void 0===d?"a":d,m=e.onBlur,y=e.onFocus,x=e.TypographyClasses,b=e.underline,J=void 0===b?"hover":b,j=e.variant,v=void 0===j?"inherit":j,X=Object(s.a)(e,["classes","className","color","component","onBlur","onFocus","TypographyClasses","underline","variant"]),Y=Object(u.a)(),C=Y.isFocusVisible,q=Y.onBlurVisible,w=Y.ref,E=l.useState(!1),k=E[0],S=E[1],O=Object(c.a)(n,w);return l.createElement(f.a,Object(a.a)({className:Object(r.a)(t.root,t["underline".concat(Object(o.a)(J))],i,k&&t.focusVisible,"button"===h&&t.button),classes:x,color:g,component:h,onBlur:function(e){k&&(q(),S(!1)),m&&m(e)},onFocus:function(e){C(e)&&S(!0),y&&y(e)},ref:O,variant:v},X))}));n.a=Object(i.a)({root:{},underlineNone:{textDecoration:"none"},underlineHover:{textDecoration:"none","&:hover":{textDecoration:"underline"}},underlineAlways:{textDecoration:"underline"},button:{position:"relative",WebkitTapHighlightColor:"transparent",backgroundColor:"transparent",outline:0,border:0,margin:0,borderRadius:0,padding:0,cursor:"pointer",userSelect:"none",verticalAlign:"middle","-moz-appearance":"none","-webkit-appearance":"none","&::-moz-focus-inner":{borderStyle:"none"},"&$focusVisible":{outline:"auto"}},focusVisible:{}},{name:"MuiLink"})(p)},745:function(e,n,t){"use strict";t.r(n);var a=t(0),s=t.n(a),l=t(189),r=t(720),o=t(734),i=t(721),u=t(63),c=t(590),f=t(73),p=t(74),g=t(81),d=t(335),h=t(722),m=t(733),y=t(82),x=t(86),b=function e(){var n=this;Object(x.a)(this,e),this.addEdge=function(e,t){void 0===n.graph[e]&&(n.graph[e]=[]),n.graph[e].push(t)},this.DFS=function(e){var t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],a=[];for(n.stack.push(e);0!==n.stack.length;){var s=n.stack.pop();if(a.push(s),void 0===n.graph[s]);else{var l=void 0;l=t?n.graph[s].slice().reverse():n.graph[s];var r,o=Object(y.a)(l);try{for(o.s();!(r=o.n()).done;){var i=r.value;n.stack.push(i)}}catch(u){o.e(u)}finally{o.f()}}}return a},this.BFS=function(e){n.queue.push(e);for(var t=[];0!==n.queue.length;){var a=n.queue.shift();if(t.push(a),void 0===n.graph[a]);else{var s,l=n.graph[a],r=Object(y.a)(l);try{for(r.s();!(s=r.n()).done;){var o=s.value;n.queue.push(o)}}catch(i){r.e(i)}finally{r.f()}}}return t},this.graph=[],this.stack=[],this.queue=[]},J=function(e){var n=e.name,t=e.index,a=e.x_position,l=e.y_position,r=Object(p.b)(),o="black";return Object(p.c)(g.h)===t&&(o="green"),s.a.createElement(s.a.Fragment,null,s.a.createElement("svg",{x:a,y:l,onClick:function(){return r(Object(g.b)({index:t}))}},s.a.createElement("circle",{cx:"30",cy:"30",r:"20",stroke:o,strokeWidth:"3",fill:"red",fillOpacity:"0.5"}),s.a.createElement("text",{textAnchor:"middle",x:"30",y:"30"},n)))},j=function e(n){var t,a=n.parentName,l=n.parentIndex,r=n.x_position,o=void 0===r?0:r,i=n.y_position,u=void 0===i?0:i,c=n.height,f=n.width,d=Object(p.c)(g.g),h=!1,m=d[a],y=[];if(t=function e(n){if("undefined"===typeof n)return 0;for(var t=0,a=0,s=Object.keys(n);a<s.length;a++){var l=s[a];t++,t+=e(d[n[l]])}return t}(m),"undefined"!==typeof m){h=!0;for(var x=0,b=Object.keys(m);x<b.length;x++){var j=b[x];y.push([j,m[j]])}}var v=25*-t;return s.a.createElement("svg",{x_position:o,y_position:u,width:f,height:c},s.a.createElement(J,{x_position:0===l?f/2:o,y_position:u,name:a,index:l}),h?y.map((function(n,a){return v+=25*t,"undefined"!==typeof d[n[1]]?s.a.createElement(e,{x_position:o+v,y_position:u+100,width:f,height:c,key:a,parentName:n[1],parentIndex:n[0]}):s.a.createElement(e,{x_position:o+v,y_position:u+100,key:a,parentName:n[1],parentIndex:n[0]})})):null)},v=new b,X=s.a.memo((function(){var e=Object(p.c)(g.i),n=Object(p.c)(g.h),t=Object(p.c)(g.e),o=Object(p.c)(g.f),c=Object(p.b)(),y=Object(a.useState)(""),x=Object(f.a)(y,2),J=x[0],X=x[1],Y=function(){e.includes(J)||(c(Object(g.a)({name:J||"Node"})),"undefined"!==typeof e[n]&&v.addEdge(e[n],J),X(""))};return s.a.createElement(l.a,{direction:"column",container:!0,spacing:2},s.a.createElement(l.a,{item:!0},s.a.createElement(r.a,null,s.a.createElement(i.a,null,s.a.createElement(l.a,{container:!0},s.a.createElement(l.a,{item:!0},s.a.createElement(u.a,{variant:"h5"},"Breadth First Search:"),s.a.createElement(u.a,null,0!==t.length?t.map((function(e){return e===t[t.length-1]?e:e+"->"})):"(BFS Path)"),s.a.createElement(u.a,{variant:"h5"},"Depth First Search:"),s.a.createElement(u.a,null,0!==o.length?o.map((function(e){return e===o[o.length-1]?e:e+"->"})):"(DFS Path)"),s.a.createElement(u.a,null,"Enter node name to draw tree graph.")))),s.a.createElement(d.a,null,s.a.createElement(h.a,{label:"Node Name",plaardceholder:"Node",variant:"outlined","aria-label":"Node name",value:J,onChange:function(e){return X(e.target.value)},onKeyPress:function(e){"Enter"===e.key&&Y()}}),s.a.createElement(m.a,{variant:"outlined",onClick:Y},"Add node"),s.a.createElement(m.a,{variant:"outlined",onClick:function(){var t=v.DFS(e[n],!0);c(Object(g.k)({DFSPath:t}))}},"Show DFS"),s.a.createElement(m.a,{variant:"outlined",onClick:function(){var t=v.BFS(e[n]);c(Object(g.j)({BFSPath:t}))}},"Show BFS"),s.a.createElement(m.a,{variant:"outlined",onClick:function(){v=new b,c(Object(g.d)())}},"Reset Tree Graph")))),s.a.createElement(l.a,{item:!0},s.a.createElement(r.a,null,s.a.createElement(i.a,null,s.a.createElement(u.a,{variant:"h4",align:"center"},"Tree Graph"),0!==e.length?s.a.createElement(j,{width:window.innerWidth/2+window.innerWidth/4,height:600,parentName:e[0],parentIndex:0}):null))))})),Y=t(201),C=t(202);n.default=function(){var e=[C.a.bfs,C.a.dfs,C.a.graphClass];return s.a.createElement(l.a,{item:!0,container:!0,direction:"column",spacing:2},s.a.createElement(l.a,{item:!0},s.a.createElement(r.a,null,s.a.createElement(o.a,{title:"DFS and BFS"}),s.a.createElement(i.a,null,s.a.createElement(u.a,{variant:"body1"},"Each node can be selected. A green highlight is around currently selected node."),s.a.createElement(u.a,{variant:"body1"},"'Add node' adds child node to the currently selected node."),s.a.createElement(u.a,{variant:"body1"},"Show DFS and Show BFS calculates path from currently selected node to all its leaf nodes."),s.a.createElement(u.a,{variant:"body1"},"Two Nodes cannot have the same name."),s.a.createElement(u.a,{variant:"body2"},"*Capable of displaying Tree of Depth 6 nodes with each node having 2 children on a full screen")))),s.a.createElement(l.a,{item:!0,container:!0},s.a.createElement(X,null)),s.a.createElement(l.a,{item:!0,xs:12},s.a.createElement(Y.a,{tabNameList:["BFS","DFS","Graph Class"],tabCodeSnippetList:e,language:"javascript"})),s.a.createElement(l.a,{item:!0},s.a.createElement(r.a,null,s.a.createElement(o.a,{title:"Adding Node"}),s.a.createElement(i.a,null,s.a.createElement(u.a,null,"   A dictionary/object is used to store list of its children to maintain relation between each node and its childrens. i.e  {'parentNode': [children]}.\nTo add node, either children are added to existing parent key or a new parent key is created to store children for that node. \nA function addEdge(node, newNode) takes two input 'node'i.e. parent Node and 'newNode'i.e. to be added child node.\n")))),s.a.createElement(l.a,{item:!0},s.a.createElement(r.a,null,s.a.createElement(o.a,{title:"Github Link"}),s.a.createElement(i.a,null,s.a.createElement(c.a,{color:"secondary",variant:"body2",href:"https://github.com/B10prajapati/AI_LAB"},"Github Link")))))}}}]);
//# sourceMappingURL=6.22945a20.chunk.js.map