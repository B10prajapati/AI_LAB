{"version":3,"sources":["components/CodeBlock.jsx","snippets/index.js","components/Grid.module.css","components/SettingsModal.jsx","components/Controls.jsx","components/TooltipContent.jsx","components/GridCell.jsx","components/SearchGrid.jsx","features/aStarSearch/AStarSearch.js","pages/lab4/lab4.js"],"names":["TabPanel","props","children","value","index","other","role","hidden","id","aria-labelledby","CodeBlock","React","useState","setValue","tabNameList","tabCodeSnippetList","language","title","onChange","event","newValue","aria-label","map","name","key","label","a11yProps","codeSnippet","style","dracula","lineProps","wordBreak","whiteSpace","wrapLines","snippets","dfs","bfs","graphClass","water_jug","water_jug_pour_rule","water_jug_rules","water_jug_solution","a_star_search_grid_generation","a_star_search_coord_and_distance","a_star_search_path_calculation","chatbot","chatbot_stem","chatbot_ask","module","exports","rand","Math","round","random","getModalStyle","top","left","transform","useStyles","makeStyles","theme","paper","position","width","backgroundColor","palette","background","border","boxShadow","shadows","padding","spacing","SettingsModal","isOpen","setOpen","classes","modalStyle","preset","useSelector","selectPreset","dispatch","useDispatch","Button","startIcon","InfoOutlined","onClick","outline","variant","color","Modal","open","onClose","Container","className","Grid","container","justify","alignItems","item","Typography","List","ListItem","text","disabled","changePreset","button","Link","href","Controls","mode","selectMode","StopOutlined","Mode","setStart","setMode","draw","setEnd","PlayArrowOutlined","calculatePath","ClearAllOutlined","clearGrid","require","Table","TableBody","TableRow","TableCell","TableContainer","Paper","TooltipContent","cell","component","isPath","isClosed","getLabel","gCost","hCost","fCost","counter","memo","rowIndex","colIndex","start","end","path","onCellClick","isChecked","animationOffset","cn","styles","gridCell","status","x","y","closed","checked","animationDelay","undefined","Tooltip","gridTooltip","SearchGrid","grid","selectGrid","selectEnd","selectPath","selectStart","isPressed","setIsPressed","onMouseDown","onMouseUp","useEffect","document","addEventListener","removeEventListener","console","log","setCellAsBlocked","gridRoot","gridTable","row","AStarSearchComponent","Card","CardContent","Lab3","direction","AStarSearch","xs","sm"],"mappings":"sMAMA,SAASA,EAASC,GAAQ,IAChBC,EAAqCD,EAArCC,SAAUC,EAA2BF,EAA3BE,MAAOC,EAAoBH,EAApBG,MAAUC,EADZ,YACsBJ,EADtB,8BAGvB,OACE,uCACEK,KAAK,WACLC,OAAQJ,IAAUC,EAClBI,GAAE,0BAAqBJ,GACvBK,kBAAA,qBAA+BL,IAC3BC,GAEHF,IAAUC,GAAS,wCAAIF,EAAJ,MAsDXQ,IAtCG,SAACT,GAAW,IAAD,EACDU,IAAMC,SAAS,GADd,mBACpBT,EADoB,KACbU,EADa,KAOnBC,EAA8Cb,EAA9Ca,YAAaC,EAAiCd,EAAjCc,mBAAoBC,EAAaf,EAAbe,SACzC,OACE,kBAAC,IAAD,KACE,kBAAC,IAAD,CAAYC,MAAM,SAClB,kBAAC,IAAD,KACE,kBAAC,IAAD,CAAMd,MAAOA,EAAOe,SATL,SAACC,EAAOC,GAC3BP,EAASO,IAQuCC,aAAW,cACpDP,EAAYQ,KAAI,SAACC,EAAMnB,GACtB,OAAO,kBAAC,IAAD,eAAKoB,IAAKpB,EAAOqB,MAAOF,GApB3C,SAAmBnB,GACjB,MAAO,CACLI,GAAG,cAAD,OAAgBJ,GAClB,gBAAgB,mBAAhB,OAAoCA,IAiBasB,CAAUtB,SAGtDW,EAAmBO,KAAI,SAACK,EAAavB,GACpC,OACE,kBAACJ,EAAD,CAAUG,MAAOA,EAAOqB,IAAKpB,EAAOA,MAAOA,GACzC,kBAAC,IAAD,CACEY,SAAUA,EACVY,MAAOC,IACPC,UAAW,CACTF,MAAO,CAAEG,UAAW,YAAaC,WAAY,aAE/CC,WAAW,GAEVN,W,iCC7DjB,kCAAO,IAAMO,EAAW,CACtBC,IAAI,6kBAwBJC,IAAI,ueAsBJC,WAAW,g6CA0DXC,UAAU,q8KA8KVC,oBAAoB,4pBA4BpBC,gBAAgB,0/DAgEhBC,mBAAmB,0vDA8EnBC,8BAA8B,oOAW9BC,iCAAiC,qnBAuBjCC,+BAA+B,+xEAqF/BC,QAAQ,6xFAsGRC,aAAa,wJAMbC,YAAY,szC,oBCnqBdC,EAAOC,QAAU,CAAC,UAAY,wBAAwB,SAAW,uBAAuB,YAAc,0BAA0B,QAAU,sBAAsB,QAAU,sBAAsB,MAAQ,oBAAoB,IAAM,kBAAkB,cAAgB,4BAA4B,OAAS,qBAAqB,aAAe,2BAA2B,KAAO,mBAAmB,WAAa,yBAAyB,YAAc,4B,+LCkBtb,SAASC,IACP,OAAOC,KAAKC,MAAsB,GAAhBD,KAAKE,UAAiB,GAE1C,SAASC,IACP,IAAMC,EAAM,GAAKL,IACXM,EAAO,GAAKN,IAElB,MAAO,CACLK,IAAI,GAAD,OAAKA,EAAL,KACHC,KAAK,GAAD,OAAKA,EAAL,KACJC,UAAU,cAAD,OAAgBF,EAAhB,eAA0BC,EAA1B,OAGb,IAAME,EAAYC,aAAW,SAACC,GAAD,MAAY,CACvCC,MAAO,CACLC,SAAU,WACVC,MAAO,IACPC,gBAAiBJ,EAAMK,QAAQC,WAAWL,MAC1CM,OAAQ,iBACRC,UAAWR,EAAMS,QAAQ,GACzBC,QAASV,EAAMW,QAAQ,EAAG,EAAG,QAsHlBC,EAnHO,WAAO,IAAD,EACA5D,oBAAS,GADT,mBACnB6D,EADmB,KACXC,EADW,KAEpBC,EAAUjB,IAFU,EAIL/C,IAAMC,SAAS0C,GAA7BsB,EAJmB,oBAMpBC,EAASC,YAAYC,KACrBC,EAAWC,cAEjB,OACE,oCACE,kBAACC,EAAA,EAAD,CACEC,UAAW,kBAACC,EAAA,EAAD,MACXC,QAAS,kBAAMX,GAAQ,IACvB9C,MAAO,CAAE0D,QAAS,GAClBC,QAAQ,YACRC,MAAM,aALR,QASA,kBAACC,EAAA,EAAD,CACEC,KAAMjB,EACNkB,QAAS,kBAAMjB,GAAQ,IACvBjE,kBAAgB,iCAEhB,kBAACmF,EAAA,EAAD,CAAWhE,MAAOgD,EAAYiB,UAAWlB,EAAQd,OAC/C,kBAACiC,EAAA,EAAD,CAAMC,WAAS,EAACxB,QAAS,EAAGyB,QAAQ,SAASC,WAAW,UACtD,kBAACH,EAAA,EAAD,CAAMI,MAAI,GACR,kBAACC,EAAA,EAAD,CAAYZ,QAAQ,MAApB,uBAEF,kBAACO,EAAA,EAAD,CAAMI,MAAI,GACR,kBAACE,EAAA,EAAD,KACE,kBAACC,EAAA,EAAD,KACE,kBAACF,EAAA,EAAD,yCAEF,kBAACE,EAAA,EAAD,KACE,kBAACF,EAAA,EAAD,mEAIF,kBAACE,EAAA,EAAD,KACE,kBAACF,EAAA,EAAD,yEAON,kBAACL,EAAA,EAAD,CAAMI,MAAI,GACR,kBAACC,EAAA,EAAD,CAAYZ,QAAQ,MAApB,mBAEF,kBAACO,EAAA,EAAD,CAAMI,MAAI,EAACH,WAAS,EAACxB,QAAS,GAC3B,CACC,CAAEM,OAAQ,cAAeyB,KAAM,eAC/B,CAAEzB,OAAQ,YAAayB,KAAM,aAC7B,CAAEzB,OAAQ,SAAUyB,KAAM,UAC1B,CAAEzB,OAAQ,QAASyB,KAAM,iBACzBhF,KAAI,SAAC4E,GAAD,OACJ,kBAACJ,EAAA,EAAD,CAAMI,MAAI,EAAC1E,IAAK0E,EAAKrB,QACnB,kBAACK,EAAA,EAAD,CACEK,QAAQ,YACRgB,SAAU1B,IAAWqB,EAAKrB,OAC1BQ,QAAS,kBACPL,EAASwB,YAAa,CAAE3B,OAAQqB,EAAKrB,WAEvCjD,MAAO,CAAE0D,QAAS,IAEjBY,EAAKI,WAKd,kBAACR,EAAA,EAAD,CAAMI,MAAI,GACR,kBAACC,EAAA,EAAD,CAAYZ,QAAQ,MAApB,8BAEF,kBAACO,EAAA,EAAD,CAAMI,MAAI,GACR,kBAACE,EAAA,EAAD,KACE,kBAACC,EAAA,EAAD,CAAUI,QAAM,GACd,kBAACC,EAAA,EAAD,CACElB,MAAM,YACND,QAAQ,QACRoB,KAAK,+CAHP,oCAQF,kBAACN,EAAA,EAAD,CAAUI,QAAM,GACd,kBAACC,EAAA,EAAD,CACElB,MAAM,YACND,QAAQ,QACRoB,KAAK,iFAHP,0EASF,kBAACN,EAAA,EAAD,CAAUI,QAAM,GACd,kBAACC,EAAA,EAAD,CACElB,MAAM,YACND,QAAQ,QACRoB,KAAK,mEAHP,mH,mCCrCHC,EAnFE,WACf,IAAMC,EAAO/B,YAAYgC,KACnB9B,EAAWC,cAEjB,OACE,kBAACa,EAAA,EAAD,CAAMC,WAAS,EAACxB,QAAS,GACvB,kBAACuB,EAAA,EAAD,CAAMI,MAAI,GACR,kBAAChB,EAAA,EAAD,CACEK,QAAQ,YACRC,MAAM,UACNL,UAAW,kBAAC4B,EAAA,EAAD,MACXR,SAAUM,IAASG,IAAKC,SACxB5B,QAAS,kBACPL,EACEkC,YAAQ,CACNL,KAAMA,IAASG,IAAKC,SAAWD,IAAKG,KAAOH,IAAKC,aAItDrF,MAAO,CAAE0D,QAAS,IAZpB,cAiBF,kBAACQ,EAAA,EAAD,CAAMI,MAAI,GACR,kBAAChB,EAAA,EAAD,CACEM,MAAM,UACND,QAAQ,YACRJ,UAAW,kBAAC4B,EAAA,EAAD,MACXR,SAAUM,IAASG,IAAKI,OACxB/B,QAAS,kBACPL,EACEkC,YAAQ,CAAEL,KAAMA,IAASG,IAAKI,OAASJ,IAAKG,KAAOH,IAAKI,WAG5DxF,MAAO,CAAE0D,QAAS,IAVpB,YAgBF,kBAACQ,EAAA,EAAD,CAAMI,MAAI,GACR,kBAAChB,EAAA,EAAD,CACEM,MAAM,UACND,QAAQ,YACRJ,UAAW,kBAAC4B,EAAA,EAAD,MACXR,SAAUM,IAASG,IAAKG,KACxB9B,QAAS,kBAAML,EAASkC,YAAQ,CAAEL,KAAMG,IAAKG,SAC7CvF,MAAO,CAAE0D,QAAS,IANpB,SAWF,kBAACQ,EAAA,EAAD,CAAMI,MAAI,GACR,kBAAChB,EAAA,EAAD,CACEM,MAAM,UACND,QAAQ,YACRJ,UAAW,kBAACkC,EAAA,EAAD,MACXhC,QAAS,kBAAML,EAASsC,gBACxB1F,MAAO,CAAE0D,QAAS,IALpB,UAUF,kBAACQ,EAAA,EAAD,CAAMI,MAAI,GACR,kBAAChB,EAAA,EAAD,CACEM,MAAM,UACND,QAAQ,YACRJ,UAAW,kBAACoC,EAAA,EAAD,MACXlC,QAAS,kBAAML,EAASwC,gBACxB5F,MAAO,CAAE0D,QAAS,IALpB,UAWF,kBAACQ,EAAA,EAAD,CAAMI,MAAI,GACR,kBAAC,EAAD,S,mBCvFJuB,EAAQ,KAPVC,E,EAAAA,MACAC,E,EAAAA,UACAC,E,EAAAA,SACAC,E,EAAAA,UACA1B,E,EAAAA,WACA2B,E,EAAAA,eACAC,E,EAAAA,MAkEaC,EAtDQ,SAAC,GAAc,IAAZC,EAAW,EAAXA,KACxB,OACE,oCACE,kBAACH,EAAD,CAAgBI,UAAWH,GACzB,kBAACL,EAAD,KACE,kBAACC,EAAD,KACE,kBAACC,EAAD,KACE,kBAACC,EAAD,KACE,kBAAC,EAAD,KAjBC,SAACI,GAChB,OAAIA,EAAKE,OACA,eACEF,EAAKG,SACP,kCAEA,gCAWkBC,CAASJ,MAI1B,kBAACL,EAAD,KACE,kBAACC,EAAD,KACE,kBAAC,EAAD,6BAEF,kBAACA,EAAD,KACE,kBAAC,EAAD,KAAaI,EAAKK,SAItB,kBAACV,EAAD,KACE,kBAACC,EAAD,KACE,kBAAC,EAAD,2BAEF,kBAACA,EAAD,KACE,kBAAC,EAAD,KAAaI,EAAKM,SAItB,kBAACX,EAAD,KACE,kBAACC,EAAD,KACE,kBAAC,EAAD,wBAEF,kBAACA,EAAD,KACE,kBAAC,EAAD,KAAaI,EAAKO,SAItB,kBAACZ,EAAD,KACE,kBAACC,EAAD,KACE,kBAAC,EAAD,wBAEF,kBAACA,EAAD,KACE,kBAAC,EAAD,KAAaI,EAAKQ,gB,oCCjBnB9H,MAAM+H,MAvCJ,SAACzI,GAAW,IAAD,QAClBgI,EAA4DhI,EAA5DgI,KAAMU,EAAsD1I,EAAtD0I,SAAUC,EAA4C3I,EAA5C2I,SAAUC,EAAkC5I,EAAlC4I,MAAOC,EAA2B7I,EAA3B6I,IAAKC,EAAsB9I,EAAtB8I,KAAMC,EAAgB/I,EAAhB+I,YAC9CZ,EAAWW,IAAI,UAAIA,EAAKJ,GAAUC,UAAnB,aAAI,EAA0BR,UAC7CD,EAASY,IAAI,UAAIA,EAAKJ,GAAUC,UAAnB,aAAI,EAA0BT,QAC3Cc,EAAYF,GAA4C,KAApC,UAAAA,EAAKJ,GAAUC,UAAf,eAA0BJ,OAC9CU,EAAkBH,EAAI,UAAGA,EAAKJ,GAAUC,UAAlB,aAAG,EAA0BH,QAAU,EAEnE,OACE,oCACE,wBACE5C,UAAWsD,IACTC,IAAOC,SACPD,IAAOnB,EAAKqB,QAFD,eAGRF,IAAOP,MAAQF,IAAaE,EAAMU,GAAKX,IAAaC,EAAMW,GAHlD,eAIRJ,IAAON,IAAMH,IAAaG,EAAIS,GAAKX,IAAaE,EAAIU,GAJ5C,eAKRJ,IAAOK,OAASrB,GALR,eAMRgB,IAAOM,QAAUT,GANT,eAORG,IAAOL,KAAOZ,IAEnB3G,IAAG,UAAKmH,EAAL,YAAiBC,GACpBvD,QAAS2D,EAAYL,EAAUC,GAC/BhH,MAAO,CACL+H,eAAgBT,EAAe,UACN,GAAlBA,EADwB,WAE3BU,IAGLb,IAASX,GAAYa,GAAad,GACjC,kBAAC0B,EAAA,EAAD,CAAS5I,MAAO,kBAAC,EAAD,CAAgBgH,KAAMc,EAAKJ,GAAUC,MACnD,yBACE/C,UAAWuD,IAAOU,YAClBlI,MAAO,CAAE4D,MAAO,kBAGlB,UCoCGuE,EA/DI,SAAC9J,GAClB,IAAM+J,EAAOlF,YAAYmF,KACnBnB,EAAMhE,YAAYoF,KAClBnB,EAAOjE,YAAYqF,KACnBtB,EAAQ/D,YAAYsF,KACpBvD,EAAO/B,YAAYgC,KAEnB9B,EAAWC,cAPW,EASMrE,oBAAS,GATf,mBASrByJ,EATqB,KASVC,EATU,KAUtBC,EAAc,kBAAMD,GAAa,IACjCE,EAAY,kBAAMF,GAAa,IAErCG,qBAAU,WAIR,OAHAC,SAASC,iBAAiB,YAAaJ,GACvCG,SAASC,iBAAiB,UAAWH,GAE9B,WACLE,SAASE,oBAAoB,YAAaL,GAC1CG,SAASE,oBAAoB,UAAWJ,MAEzC,IAEH,IAAMxB,EAAc,SAACL,EAAUC,GAAX,OAAwB,WAC1CiC,QAAQC,IAAInC,EAAUC,GAClB/B,IAASG,IAAKG,KAChBnC,EAAS+F,YAAiB,CAAExB,EAAGZ,EAAUa,EAAGZ,KACnC/B,IAASG,IAAKC,SACvBjC,EAASiC,YAAS,CAAEsC,EAAGZ,EAAUa,EAAGZ,KAC3B/B,IAASG,IAAKI,QACvBpC,EAASoC,YAAO,CAAEmC,EAAGZ,EAAUa,EAAGZ,OAItC,OACE,yBAAK/C,UAAWuD,IAAO4B,UACrB,2BAAOnF,UAAWuD,IAAO6B,WACvB,+BACGjB,EAAK1I,KAAI,SAAC4J,EAAKvC,GAAN,OACR,wBAAInH,IAAKmH,EAAU/G,MAAO,CAAEuC,OAAQ,oBACjC+G,EAAI5J,KAAI,SAAC2G,EAAMW,GAAP,OACP,kBAAC,EACK,CACFpH,IAAI,GAAD,OAAKmH,EAAL,cAAmBC,GACtBX,OACAU,WACAC,WACAC,QACAC,MACAC,OACAsB,YACArB,YAAaA,eC5ClBmC,EAjBc,WAC3B,OACE,kBAACC,EAAA,EAAD,KACE,kBAACC,EAAA,EAAD,KACE,kBAACvF,EAAA,EAAD,CAAMC,WAAS,EAACxB,QAAS,EAAGyB,QAAQ,SAASC,WAAW,UACtD,kBAACH,EAAA,EAAD,CAAMI,MAAI,GACR,kBAAC,EAAD,OAEF,kBAACJ,EAAA,EAAD,CAAMI,MAAI,GACR,kBAAC,EAAD,W,kBCeGoF,UAvBF,WACX,IACMvK,EAAqB,CACzBmB,IAASQ,8BACTR,IAASS,iCACTT,IAASU,gCAGX,OACE,kBAACkD,EAAA,EAAD,CAAMI,MAAI,EAACH,WAAS,EAACwF,UAAU,SAAShH,QAAS,GAC/C,kBAACuB,EAAA,EAAD,CAAMI,MAAI,GACR,kBAACsF,EAAD,OAEF,kBAAC1F,EAAA,EAAD,CAAMI,MAAI,EAACuF,GAAI,GAAIC,GAAI,IACrB,kBAAChL,EAAA,EAAD,CACEI,YAdY,CAAC,kBAAmB,OAAQ,oBAexCC,mBAAoBA,EACpBC,SAAS","file":"static/js/7.238f9888.chunk.js","sourcesContent":["import { Card, CardContent, CardHeader, Tab, Tabs } from \"@material-ui/core\";\nimport React from \"react\";\nimport SyntaxHighlighter from \"react-syntax-highlighter\";\n\nimport { dracula } from \"react-syntax-highlighter/dist/esm/styles/hljs\";\nimport { PropTypes } from \"prop-types\";\nfunction TabPanel(props) {\n  const { children, value, index, ...other } = props;\n\n  return (\n    <div\n      role=\"tabpanel\"\n      hidden={value !== index}\n      id={`simple-tabpanel-${index}`}\n      aria-labelledby={`simple-tab-${index}`}\n      {...other}\n    >\n      {value === index && <> {children} </>}\n    </div>\n  );\n}\n\nTabPanel.propTypes = {\n  children: PropTypes.node,\n  index: PropTypes.any.isRequired,\n  value: PropTypes.any.isRequired,\n};\nfunction a11yProps(index) {\n  return {\n    id: `simple-tab-${index}`,\n    \"aria-controls\": `simple-tabpanel-${index}`,\n  };\n}\nconst CodeBlock = (props) => {\n  const [value, setValue] = React.useState(0);\n\n  const handleChange = (event, newValue) => {\n    setValue(newValue);\n  };\n\n  const { tabNameList, tabCodeSnippetList, language } = props;\n  return (\n    <Card>\n      <CardHeader title=\"Code\" />\n      <CardContent>\n        <Tabs value={value} onChange={handleChange} aria-label=\"Tree Graph\">\n          {tabNameList.map((name, index) => {\n            return <Tab key={index} label={name} {...a11yProps(index)} />;\n          })}\n        </Tabs>\n        {tabCodeSnippetList.map((codeSnippet, index) => {\n          return (\n            <TabPanel value={value} key={index} index={index}>\n              <SyntaxHighlighter\n                language={language}\n                style={dracula}\n                lineProps={{\n                  style: { wordBreak: \"break-all\", whiteSpace: \"pre-wrap\" },\n                }}\n                wrapLines={true}\n              >\n                {codeSnippet}\n              </SyntaxHighlighter>\n            </TabPanel>\n          );\n        })}\n      </CardContent>\n    </Card>\n  );\n};\n\nexport default CodeBlock;\n","export const snippets = {\n  dfs: `\n  DFS = (key, rev = false) => {\n    let dfs = [];\n    this.stack.push(key);\n    while (1) {\n      if (this.stack.length === 0) {\n        // array empty or does not exist\n        break;\n      }\n      const popped = this.stack.pop();\n\n      dfs.push(popped);\n      if (this.graph[popped] === undefined) {\n      } else {\n        let childData;\n        if (rev) childData = this.graph[popped].slice().reverse();\n        else childData = this.graph[popped];\n        for (let i of childData) {\n          this.stack.push(i);\n        }\n      }\n    }\n    return dfs;\n  };`,\n  bfs: `\n  BFS = (key) => {\n    this.queue.push(key);\n    let bfs = [];\n    while (1) {\n      if (this.queue.length === 0) {\n        // array empty or does not exist\n        break;\n      }\n      const popped = this.queue.shift();\n      bfs.push(popped);\n\n      if (this.graph[popped] === undefined) {\n      } else {\n        const childData = this.graph[popped];\n        for (let i of childData) {\n          this.queue.push(i);\n        }\n      }\n    }\n    return bfs;\n  };`,\n  graphClass: `\n  class Graph {\n    constructor() {\n      this.graph = [];\n      this.stack = [];\n      this.queue = [];\n    }\n    addEdge = (node, newNode) => {\n      if (this.graph[node] === undefined) this.graph[node] = [];\n      this.graph[node].push(newNode);\n    };\n  \n    DFS = (key, rev = false) => {\n      let dfs = [];\n      this.stack.push(key);\n      while (1) {\n        if (this.stack.length === 0) {\n          // array empty or does not exist\n          break;\n        }\n        const popped = this.stack.pop();\n  \n        dfs.push(popped);\n        if (this.graph[popped] === undefined) {\n        } else {\n          let childData;\n          if (rev) childData = this.graph[popped].slice().reverse();\n          else childData = this.graph[popped];\n          for (let i of childData) {\n            this.stack.push(i);\n          }\n        }\n      }\n      return dfs;\n    };\n    BFS = (key) => {\n      this.queue.push(key);\n      let bfs = [];\n      while (1) {\n        if (this.queue.length === 0) {\n          // array empty or does not exist\n          break;\n        }\n        const popped = this.queue.shift();\n        bfs.push(popped);\n  \n        if (this.graph[popped] === undefined) {\n        } else {\n          const childData = this.graph[popped];\n          for (let i of childData) {\n            this.queue.push(i);\n          }\n        }\n      }\n      return bfs;\n    };\n  }\n  `,\n  water_jug: `\n  class WaterJug():\n    def __init__(self,x,y,target):\n        self.capX = x\n        self.capY = y\n        self.x = 0\n        self.y = 0\n        self.targe,end='\\\\n\\\\n\\\\n't = target\n        self.path = []\n        \n    def rule(self,x, d=0):\n        w.printVolume()\n        print('Rule {}'.format(x),end=' ')\n        # fill capX gallon jug completely\n        if(x==1):\n                if self.x<self.capX:\n                    self.x=self.capX\n                print('Fill jugX completely')\n        # fill capY gallon jug completely\n        elif (x==2):\n                if self.y<self.capY:\n                    self.y=self.capY\n                print('Fill jugY completely')\n        # pour some part from x jug\n        elif(x==3):\n                if self.x>0:\n                    self.x= self.x - d\n                print('Pour Some part D from X jug')\n        # pour some part from y jug        \n        elif(x==4):\n                if self.y>0:\n                    self.y = self.y - d\n                \n                print('Pour Some part D from Y jug')\n        # empty jug x        \n        elif(x==5):\n                if self.x>0:\n                    self.x=0\n                print('Empty jugX')\n        # empty jug y        \n        elif(x==6):\n                if self.y>0:\n                    self.y=0\n                print('Empty jugY')\n        # pour water from y jug to fill x jug        \n        elif(x==7):\n                if self.x+self.y < self.capX+self.capY:\n                    self.y= self.y-(self.capX-self.x)\n                    self.x = self.capX\n                print('Pour from jugY to fill jugX')\n        #pour water from x jug to fill y jug\n        elif(x==8):\n                if self.x+self.y < self.capX+self.capY:\n                    self.x=self.x-(self.capY-self.y)\n                    self.y = self.capY\n                print('Pour from jugX to fill jugY')\n        # pour all water from y jug to x jug\n        elif(x==9):\n                if self.x+self.y < self.capX:\n                    self.x= self.x+self.y\n                    self.y=0\n                print('Pour all from jugY to jugX')\n        #pour all water from x jug to y jug\n        elif(x==10):\n                if self.x+self.y < self.capY:\n                    self.x=0\n                    self.y=self.x+self.y     \n                    print('Pour all from jugX to jugY')\n\n        w.printVolume()\n        print('---')\n        self.appendPath()\n             \n    def printVolume(self):\n        print('[JugX={}, JugY={}]'.format(self.x, self.y))\n    \n    # print each state leading upto solution\n    def printPath(self):\n        for state in self.path:\n            if state==self.path[-1]:\n                print(f'[JugX:{state[0]}, JugY:{state[1]}]')\n                continue\n            print(f'[JugX:{state[0]}, JugY:{state[1]}]', end='->')\n    \n    # add new state generated to path\n    def appendPath(self):\n        self.path.append([self.x, self.y])\n    \n    def reset(self):\n        self.x=0\n        self.y=0\n        self.path=[]\n        \n    def pour(self): \n        self.reset()\n        yJug= self.capY\n        xJug=0\n#         self.rule(2)\n        step = 1\n        while ((yJug  is not self.target) and (xJug is not self.target)): \n            print('({},{})'.format(xJug, yJug))\n            \n\n            if(yJug < (self.capX-xJug)):\n                temp = yJug\n#                 self.rule(9)\n            else:\n                temp = (self.capX-xJug)\n#                 self.rule(7)\n            xJug = xJug + temp\n            yJug = yJug - temp\n\n#             temp = min(yJug, self.capX-xJug) \n#             xJug = xJug + temp \n#             yJug = yJug - temp \n\n            print('({},{})'.format(xJug, yJug))\n\n            step =  step + 1\n            if ((yJug == self.target) or (xJug == self.target)): \n                break\n\n            if yJug == 0: \n                yJug = self.capY\n#                 self.rule(2)\n                step =  step + 1\n\n            if xJug == self.capX: \n                xJug = 0\n#                 self.rule(5)\n                step =  step + 1\n    \n    # Solve using rules\n    def pourRule(self):\n        self.reset()\n        self.rule(2)\n        step = 1\n        while(1):\n            if(self.y==self.target or self.x==self.target):\n                break\n            \n            if(self.y < (self.capX-self.x)):\n                self.rule(9)\n            else:\n                self.rule(7)\n            \n            step=step+1\n            if(self.y==self.target or self.x==self.target):\n                break\n            \n            if self.y==0:\n                self.rule(2)\n                step = step + 1\n            \n            if self.x==self.capX:\n                self.rule(5)\n                step = step+1\n        return step \n\n    # Reverse the capacity of jugs\n    def reverseJugCapacity(self):\n        self.capX, self.capY = self.capY, self.capX\n    \n    # Solve  for both x,y and y,x conditions \n    def solve(self):\n        print(f'With JugXCapacity {self.capX} and JugYCapacity {self.capY}',end='\\\\n\\\\n\\\\n')\n        print(f'Total steps to solve : {self.pourRule()}',end='\\\\n\\\\n')\n        self.printPath()\n        print('*'*100)\n        print(f'With JugXCapacity {self.capX} and JugYCapacity {self.capY}',end='\\\\n\\\\n\\\\n')\n        self.reverseJugCapacity()\n        print(f'Total steps to solve : {self.pourRule()}',end='\\\\n\\\\n')\n        self.printPath()\n  `,\n  water_jug_pour_rule: `\n  # Solve using rules\n  def pourRule(self):\n      self.reset()\n      self.rule(2)\n      step = 1\n      while(1):\n          if(self.y==self.target or self.x==self.target):\n              break\n          \n          if(self.y < (self.capX-self.x)):\n              self.rule(9)\n          else:\n              self.rule(7)\n          \n          step=step+1\n          if(self.y==self.target or self.x==self.target):\n              break\n          \n          if self.y==0:\n              self.rule(2)\n              step = step + 1\n          \n          if self.x==self.capX:\n              self.rule(5)\n              step = step+1\n      return step \n  `,\n  water_jug_rules: `\n  def rule(self,x, d=0):\n    w.printVolume()\n    print('Rule {}'.format(x),end=' ')\n    # fill capX gallon jug completely\n    if(x==1):\n            if self.x<self.capX:\n                self.x=self.capX\n            print('Fill jugX completely')\n    # fill capY gallon jug completely\n    elif (x==2):\n            if self.y<self.capY:\n                self.y=self.capY\n            print('Fill jugY completely')\n    # pour some part from x jug\n    elif(x==3):\n            if self.x>0:\n                self.x= self.x - d\n            print('Pour Some part D from X jug')\n    # pour some part from y jug        \n    elif(x==4):\n            if self.y>0:\n                self.y = self.y - d\n            \n            print('Pour Some part D from Y jug')\n    # empty jug x        \n    elif(x==5):\n            if self.x>0:\n                self.x=0\n            print('Empty jugX')\n    # empty jug y        \n    elif(x==6):\n            if self.y>0:\n                self.y=0\n            print('Empty jugY')\n    # pour water from y jug to fill x jug        \n    elif(x==7):\n            if self.x+self.y < self.capX+self.capY:\n                self.y= self.y-(self.capX-self.x)\n                self.x = self.capX\n            print('Pour from jugY to fill jugX')\n    #pour water from x jug to fill y jug\n    elif(x==8):\n            if self.x+self.y < self.capX+self.capY:\n                self.x=self.x-(self.capY-self.y)\n                self.y = self.capY\n            print('Pour from jugX to fill jugY')\n    # pour all water from y jug to x jug\n    elif(x==9):\n            if self.x+self.y < self.capX:\n                self.x= self.x+self.y\n                self.y=0\n            print('Pour all from jugY to jugX')\n    #pour all water from x jug to y jug\n    elif(x==10):\n            if self.x+self.y < self.capY:\n                self.x=0\n                self.y=self.x+self.y     \n                print('Pour all from jugX to jugY')\n\n    w.printVolume()\n    print('---')\n    self.appendPath()\n  `,\n  water_jug_solution: `\n  w = WaterJug(5,3,4)\n  w.solve()\n  \n  OUTPUT:\n    With JugXCapacity 5 and JugYCapacity 3\n\n\n    [JugX=0, JugY=0]\n    Rule 2 Fill jugY completely\n    [JugX=0, JugY=3]\n    ---\n    [JugX=0, JugY=3]\n    Rule 9 Pour all from jugY to jugX\n    [JugX=3, JugY=0]\n    ---\n    [JugX=3, JugY=0]\n    Rule 2 Fill jugY completely\n    [JugX=3, JugY=3]\n    ---\n    [JugX=3, JugY=3]\n    Rule 7 Pour from jugY to fill jugX\n    [JugX=5, JugY=1]\n    ---\n    [JugX=5, JugY=1]\n    Rule 5 Empty jugX\n    [JugX=0, JugY=1]\n    ---\n    [JugX=0, JugY=1]\n    Rule 9 Pour all from jugY to jugX\n    [JugX=1, JugY=0]\n    ---\n    [JugX=1, JugY=0]\n    Rule 2 Fill jugY completely\n    [JugX=1, JugY=3]\n    ---\n    [JugX=1, JugY=3]\n    Rule 9 Pour all from jugY to jugX\n    [JugX=4, JugY=0]\n    ---\n    Total steps to solve : 8\n\n    [JugX:0, JugY:3]-> [JugX:3, JugY:0]-> [JugX:3, JugY:3]-> [JugX:5, JugY:1]->\n    [JugX:0, JugY:1]-> [JugX:1, JugY:0]-> [JugX:1, JugY:3]-> [JugX:4, JugY:0]\n    *****************************************************\n    With JugXCapacity 5 and JugYCapacity 3\n\n\n    [JugX=0, JugY=0]\n    Rule 2 Fill jugY completely\n    [JugX=0, JugY=5]\n    ---\n    [JugX=0, JugY=5]\n    Rule 7 Pour from jugY to fill jugX\n    [JugX=3, JugY=2]\n    ---\n    [JugX=3, JugY=2]\n    Rule 5 Empty jugX\n    [JugX=0, JugY=2]\n    ---\n    [JugX=0, JugY=2]\n    Rule 9 Pour all from jugY to jugX\n    [JugX=2, JugY=0]\n    ---\n    [JugX=2, JugY=0]\n    Rule 2 Fill jugY completely\n    [JugX=2, JugY=5]\n    ---\n    [JugX=2, JugY=5]\n    Rule 7 Pour from jugY to fill jugX\n    [JugX=3, JugY=4]\n    ---\n    Total steps to solve : 6\n\n    [JugX:0, JugY:5]->[JugX:3, JugY:2]->[JugX:0, JugY:2]\n    ->[JugX:2, JugY:0]->[JugX:2, JugY:5]->[JugX:3, JugY:4]\n\n  `,\n  a_star_search_grid_generation: `\n  const generateGrid = (numbeOfRows, numberOfColumns, value) => {\n    return range(numbeOfRows).map((x) =>\n      range(numberOfColumns).map((y) => ({\n        ...value,\n        x,\n        y,\n      }))\n    );\n  };\n  `,\n  a_star_search_coord_and_distance: `\n  const coordinatesToCheck = [\n    { y: 0, x: -1 },\n    { y: 1, x: -1 },\n    { y: 1, x: 0 },\n    { y: 1, x: 1 },\n    { y: 0, x: 1 },\n    { y: -1, x: 1 },\n    { y: -1, x: 0 },\n    { y: -1, x: -1 },\n  ];\n  \n  const getDistance = (a, b) => {\n    const colOffset = Math.abs(a.y - b.y);\n    const rowOffset = Math.abs(a.x - b.x);\n    const numberOfStraightSegments = Math.abs(colOffset - rowOffset);\n    const numberOfDiagonalSegments =\n      Math.max(colOffset, rowOffset) - numberOfStraightSegments;\n  \n    return numberOfStraightSegments * 10 + numberOfDiagonalSegments * 14; // 14 ~ 10 * sqrt(2)\n  };  \n  `,\n\n  a_star_search_path_calculation: `  \n  export const computePath = (mainGrid, start, end) => {\n    const gridLength = mainGrid.length;\n\n    let counter = 0;\n    let openList = [];\n    const grid = generateGrid(gridLength, gridLength, {\n      fCost: 0,\n      gCost: 0,\n      hCost: 0,\n      parent: undefined,\n      isClosed: false,\n      isPath: false,\n      counter: 0,\n      x: 0,\n      y: 0,\n    });\n    openList.push(grid[start.x][start.y]);\n\n    while (openList.length > 0) {\n      const currentCell = minBy(openList, (c) => c.fCost);\n\n      if (!currentCell) {\n        // no path found\n        return grid;\n      }\n\n      if (currentCell.x === end.x && currentCell.y === end.y) {\n        let curr = currentCell;\n\n        while (curr.parent) {\n          grid[curr.x][curr.y].isPath = true;\n          curr = curr.parent;\n        }\n\n        return grid;\n      }\n\n      remove(openList, (c) => c.x === currentCell.x && c.y === currentCell.y);\n      currentCell.isClosed = true;\n      // eslint-disable-next-line no-loop-func\n      coordinatesToCheck.forEach((coordinatesToCheck) => {\n        const { x, y } = {\n          x: currentCell.x + coordinatesToCheck.x,\n          y: currentCell.y + coordinatesToCheck.y,\n        };\n\n        if (\n          x < 0 ||\n          x >= gridLength ||\n          y < 0 ||\n          y >= gridLength ||\n          (start.x === x && start.y === y) ||\n          grid[x][y].isClosed ||\n          mainGrid[x][y].status === \"blocked\"\n        ) {\n          return;\n        }\n\n        const neighbourCell = grid[x][y];\n\n        const gCost = currentCell.gCost + getDistance(currentCell, neighbourCell);\n        let gCostIsBest = false;\n\n        if (!openList.find((c) => c.x === x && c.y === y)) {\n          gCostIsBest = true;\n          neighbourCell.hCost = getDistance(neighbourCell, end);\n          openList.push(neighbourCell);\n        } else if (gCost < neighbourCell.gCost) {\n          gCostIsBest = true;\n        }\n\n        if (gCostIsBest) {\n          neighbourCell.parent = currentCell;\n          neighbourCell.gCost = gCost;\n          neighbourCell.fCost = neighbourCell.gCost + neighbourCell.hCost;\n          counter = counter + 1;\n          neighbourCell.counter = counter;\n        }\n      });\n    }\n    // No path found\n    return grid;\n  };\n  `,\n  chatbot: `\n  import natural from \"natural\";\n\n  class Chatbot {  \n    constructor(name = \"Agent\") {\n      this.name = name;\n      this.questions = {};\n    }\n  \n    addQuestionsAnswer = (questions, answer) => {\n      let question;\n      for (question of questions) {\n        this.questions[question] = answer;\n      }\n    };\n  \n    //  stem words (fast but abstract words)\n    stemSentence = (sentence) => {\n      return natural.PorterStemmer.tokenizeAndStem(sentence);\n    };\n  \n    ask = (question) => {\n      question = question.toLowerCase().trim();\n      const questionWordList = this.stemSentence(question);\n      let index = 0;\n      let match = [];\n      //console.log(questionWordList);\n      let ques;\n      for (ques of Object.keys(this.questions)) {\n        ques = ques.toLowerCase().trim();\n        //console.log(ques);\n        const quesWordList = this.stemSentence(ques);\n        // console.log(quesWordList);\n        match.push(0);\n        let count = 0;\n        let word;\n        for (word of quesWordList) {\n          count += 1;\n          if (questionWordList.includes(word)) {\n            match[index] += 1;\n          }\n        }\n        match[index] = match[index] / Math.max(count, 1);\n        index += 1;\n        //  console.log(ques)\n        //  console.log(question)\n        // if (ques.toLowerCase().trim() === question) {\n        //   console.log(match);\n  \n        //   console.log(match.index(match.max));\n        //   return this.questions[ques];\n        // }\n      }\n      console.log(match);\n      const max = Math.max(...match);\n      console.log(max);\n      if (max >= 0.3) {\n        //  [match.index(max(match))]\n        const bestQuestionMatch = Object.keys(this.questions)[match.indexOf(max)];\n        return this.questions[bestQuestionMatch];\n      }\n      return \"I did not understand the question!\";\n    };\n  \n    listQuestions = () => {\n      var question;\n      let questionList = [];\n      for (question of Object.keys(this.questions)) {\n        // console.log(question);\n        questionList.push(question);\n      }\n      // console.log(questionList);\n      return questionList;\n    };\n  \n    initiateChat = () => {\n      // console.log(\"Chat with {this.name}\");\n      // console.log(\"Availabe questions for {this.name}\");\n      this.listQuestions();\n  \n      while (1) {\n        //var question = prompt(\"Enter question for {this.name} \\n\");\n        const question = \"Hi\";\n        if (\n          [\n            \"quit\",\n            \"exit\",\n            \"close\",\n            \"stop\",\n            \"end\",\n            \".\",\n            \"annihilate\",\n            \"disconnect\",\n          ].includes(question)\n        ) {\n          break;\n        }\n        // console.log(\"{this.ask(question)}\");\n      }\n    };\n  }   \n  `,\n  chatbot_stem: `\n  //  stem words (fast but abstract words)\n  stemSentence = (sentence) => {\n    return natural.PorterStemmer.tokenizeAndStem(sentence);\n  };\n  `,\n  chatbot_ask: `\n  ask = (question) => {\n    question = question.toLowerCase().trim();\n    const questionWordList = this.stemSentence(question);\n    let index = 0;\n    let match = [];\n    //console.log(questionWordList);\n    let ques;\n    for (ques of Object.keys(this.questions)) {\n      ques = ques.toLowerCase().trim();\n      //console.log(ques);\n      const quesWordList = this.stemSentence(ques);\n      // console.log(quesWordList);\n      match.push(0);\n      let count = 0;\n      let word;\n      for (word of quesWordList) {\n        count += 1;\n        if (questionWordList.includes(word)) {\n          match[index] += 1;\n        }\n      }\n      match[index] = match[index] / Math.max(count, 1);\n      index += 1;\n      //  console.log(ques)\n      //  console.log(question)\n      // if (ques.toLowerCase().trim() === question) {\n      //   console.log(match);\n\n      //   console.log(match.index(match.max));\n      //   return this.questions[ques];\n      // }\n    }\n    console.log(match);\n    const max = Math.max(...match);\n    console.log(max);\n    if (max >= 0.3) {\n      //  [match.index(max(match))]\n      const bestQuestionMatch = Object.keys(this.questions)[match.indexOf(max)];\n      return this.questions[bestQuestionMatch];\n    }\n    return \"I did not understand the question!\";\n  };\n  `,\n};\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"gridTable\":\"Grid_gridTable__1LghC\",\"gridCell\":\"Grid_gridCell__3p4DB\",\"gridTooltip\":\"Grid_gridTooltip___eKIf\",\"blocked\":\"Grid_blocked__JkDxv\",\"checked\":\"Grid_checked__27eM_\",\"start\":\"Grid_start__myL7-\",\"end\":\"Grid_end__XB9oW\",\"fadeInChecked\":\"Grid_fadeInChecked__9eRlO\",\"closed\":\"Grid_closed__lDSnE\",\"fadeInClosed\":\"Grid_fadeInClosed__2m-0b\",\"path\":\"Grid_path__14bdQ\",\"fadeInPath\":\"Grid_fadeInPath__iQwuY\",\"tooltipRoot\":\"Grid_tooltipRoot__1JPCq\"};","import {\n  Button,\n  Container,\n  Grid,\n  Link,\n  List,\n  ListItem,\n  makeStyles,\n  Modal,\n  Typography,\n} from \"@material-ui/core\";\nimport { InfoOutlined } from \"@material-ui/icons\";\nimport React, { useState } from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport {\n  changePreset,\n  selectPreset,\n} from \"../features/aStarSearch/aStarSearchSlice\";\n\nfunction rand() {\n  return Math.round(Math.random() * 20) - 10;\n}\nfunction getModalStyle() {\n  const top = 50 + rand();\n  const left = 50 + rand();\n\n  return {\n    top: `${top}%`,\n    left: `${left}%`,\n    transform: `translate(-${top}%, -${left}%)`,\n  };\n}\nconst useStyles = makeStyles((theme) => ({\n  paper: {\n    position: \"absolute\",\n    width: 400,\n    backgroundColor: theme.palette.background.paper,\n    border: \"2px solid #000\",\n    boxShadow: theme.shadows[5],\n    padding: theme.spacing(2, 4, 3),\n  },\n}));\nconst SettingsModal = () => {\n  const [isOpen, setOpen] = useState(false);\n  const classes = useStyles();\n  // getModalStyle is not a pure function, we roll the style only on the first render\n  const [modalStyle] = React.useState(getModalStyle);\n\n  const preset = useSelector(selectPreset);\n  const dispatch = useDispatch();\n\n  return (\n    <>\n      <Button\n        startIcon={<InfoOutlined />}\n        onClick={() => setOpen(true)}\n        style={{ outline: 0 }}\n        variant=\"contained\"\n        color=\"secondary\"\n      >\n        Info\n      </Button>\n      <Modal\n        open={isOpen}\n        onClose={() => setOpen(false)}\n        aria-labelledby=\"A Star Pathfinding React Demo\"\n      >\n        <Container style={modalStyle} className={classes.paper}>\n          <Grid container spacing={4} justify=\"center\" alignItems=\"center\">\n            <Grid item>\n              <Typography variant=\"h5\">How does it work ?</Typography>\n            </Grid>\n            <Grid item>\n              <List>\n                <ListItem>\n                  <Typography>Press start to compute the path</Typography>\n                </ListItem>\n                <ListItem>\n                  <Typography>\n                    Hover over the cells to see more details about the result\n                  </Typography>\n                </ListItem>\n                <ListItem>\n                  <Typography>\n                    Use the set start/end and draw button to change the\n                    obstacles\n                  </Typography>\n                </ListItem>\n              </List>\n            </Grid>\n            <Grid item>\n              <Typography variant=\"h5\">Change Pattern</Typography>\n            </Grid>\n            <Grid item container spacing={2}>\n              {[\n                { preset: \"a-star-text\", text: \"A-Star Text\" },\n                { preset: \"labyrinth\", text: \"Labyrinth\" },\n                { preset: \"random\", text: \"Random\" },\n                { preset: \"blank\", text: \"Blank Canvas\" },\n              ].map((item) => (\n                <Grid item key={item.preset}>\n                  <Button\n                    variant=\"contained\"\n                    disabled={preset === item.preset}\n                    onClick={() =>\n                      dispatch(changePreset({ preset: item.preset }))\n                    }\n                    style={{ outline: 0 }}\n                  >\n                    {item.text}\n                  </Button>\n                </Grid>\n              ))}\n            </Grid>\n            <Grid item>\n              <Typography variant=\"h5\">Ressources I found useful</Typography>\n            </Grid>\n            <Grid item>\n              <List>\n                <ListItem button>\n                  <Link\n                    color=\"secondary\"\n                    variant=\"body2\"\n                    href=\"https://www.youtube.com/watch?v=-L-WgKMFuhE\"\n                  >\n                    Sebastian Lague's Youtube Video\n                  </Link>\n                </ListItem>\n                <ListItem button>\n                  <Link\n                    color=\"secondary\"\n                    variant=\"body2\"\n                    href=\"https://briangrinstead.com/blog/astar-search-algorithm-in-javascript-updated/\"\n                  >\n                    Brian Grinstead's blog article on A* implementation and\n                    optimization.\n                  </Link>\n                </ListItem>\n                <ListItem button>\n                  <Link\n                    color=\"secondary\"\n                    variant=\"body2\"\n                    href=\"http://www.codeblocq.com/2020/01/A-Star-Pathfinding-React-Demo/\"\n                  >\n                    Jonathan Klughertz's blog on implementation of a* in react.\n                    Design and code concept from the blog demo.\n                  </Link>\n                </ListItem>\n              </List>\n            </Grid>\n          </Grid>\n        </Container>\n      </Modal>\n    </>\n  );\n};\n\nexport default SettingsModal;\n","import React from \"react\";\n\nimport SettingsModal from \"./SettingsModal\";\n\nimport { Button, Grid } from \"@material-ui/core\";\nimport {\n  ClearAllOutlined,\n  PlayArrowOutlined,\n  StopOutlined,\n} from \"@material-ui/icons\";\nimport {\n  calculatePath,\n  clearGrid,\n  selectMode,\n  setMode,\n} from \"../features/aStarSearch/aStarSearchSlice\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport { Mode } from \"../features/aStarSearch/constants\";\n\nconst Controls = () => {\n  const mode = useSelector(selectMode);\n  const dispatch = useDispatch();\n\n  return (\n    <Grid container spacing={2}>\n      <Grid item>\n        <Button\n          variant=\"contained\"\n          color=\"primary\"\n          startIcon={<StopOutlined />}\n          disabled={mode === Mode.setStart}\n          onClick={() =>\n            dispatch(\n              setMode({\n                mode: mode === Mode.setStart ? Mode.draw : Mode.setStart,\n              })\n            )\n          }\n          style={{ outline: 0 }}\n        >\n          SET START\n        </Button>\n      </Grid>\n      <Grid item>\n        <Button\n          color=\"primary\"\n          variant=\"contained\"\n          startIcon={<StopOutlined />}\n          disabled={mode === Mode.setEnd}\n          onClick={() =>\n            dispatch(\n              setMode({ mode: mode === Mode.setEnd ? Mode.draw : Mode.setEnd })\n            )\n          }\n          style={{ outline: 0 }}\n        >\n          SET END\n        </Button>\n      </Grid>\n\n      <Grid item>\n        <Button\n          color=\"primary\"\n          variant=\"contained\"\n          startIcon={<StopOutlined />}\n          disabled={mode === Mode.draw}\n          onClick={() => dispatch(setMode({ mode: Mode.draw }))}\n          style={{ outline: 0 }}\n        >\n          DRAW\n        </Button>\n      </Grid>\n      <Grid item>\n        <Button\n          color=\"primary\"\n          variant=\"contained\"\n          startIcon={<PlayArrowOutlined />}\n          onClick={() => dispatch(calculatePath())}\n          style={{ outline: 0 }}\n        >\n          START\n        </Button>\n      </Grid>\n      <Grid item>\n        <Button\n          color=\"primary\"\n          variant=\"contained\"\n          startIcon={<ClearAllOutlined />}\n          onClick={() => dispatch(clearGrid())}\n          style={{ outline: 0 }}\n        >\n          RESET\n        </Button>\n      </Grid>\n\n      <Grid item>\n        <SettingsModal />\n      </Grid>\n    </Grid>\n  );\n};\n\nexport default Controls;\n","import React from \"react\";\nconst {\n  Table,\n  TableBody,\n  TableRow,\n  TableCell,\n  Typography,\n  TableContainer,\n  Paper,\n} = require(\"@material-ui/core\");\n\nconst getLabel = (cell) => {\n  if (cell.isPath) {\n    return \"Optimal Path\";\n  } else if (cell.isClosed) {\n    return \"Considered for the optimal path\";\n  } else {\n    return \"Computed but never considered\";\n  }\n};\nconst TooltipContent = ({ cell }) => {\n  return (\n    <>\n      <TableContainer component={Paper}>\n        <Table>\n          <TableBody>\n            <TableRow>\n              <TableCell>\n                <Typography>{getLabel(cell)}</Typography>\n              </TableCell>\n            </TableRow>\n\n            <TableRow>\n              <TableCell>\n                <Typography>Distance from Start</Typography>\n              </TableCell>\n              <TableCell>\n                <Typography>{cell.gCost}</Typography>\n              </TableCell>\n            </TableRow>\n\n            <TableRow>\n              <TableCell>\n                <Typography>Distance from End</Typography>\n              </TableCell>\n              <TableCell>\n                <Typography>{cell.hCost}</Typography>\n              </TableCell>\n            </TableRow>\n\n            <TableRow>\n              <TableCell>\n                <Typography>Sum of the Two</Typography>\n              </TableCell>\n              <TableCell>\n                <Typography>{cell.fCost}</Typography>\n              </TableCell>\n            </TableRow>\n\n            <TableRow>\n              <TableCell>\n                <Typography>Steps to reach</Typography>\n              </TableCell>\n              <TableCell>\n                <Typography>{cell.counter}</Typography>\n              </TableCell>\n            </TableRow>\n          </TableBody>\n        </Table>\n      </TableContainer>\n    </>\n  );\n};\n\nexport default TooltipContent;\n","import { Tooltip } from \"@material-ui/core\";\n\nimport React from \"react\";\nimport TooltipContent from \"./TooltipContent\";\n\nimport cn from \"classnames\";\nimport styles from \"./Grid.module.css\";\n\nconst GridCell = (props) => {\n  const { cell, rowIndex, colIndex, start, end, path, onCellClick } = props;\n  const isClosed = path && path[rowIndex][colIndex]?.isClosed;\n  const isPath = path && path[rowIndex][colIndex]?.isPath;\n  const isChecked = path && path[rowIndex][colIndex]?.fCost !== 0;\n  const animationOffset = path ? path[rowIndex][colIndex]?.counter : 0;\n\n  return (\n    <>\n      <td\n        className={cn(\n          styles.gridCell,\n          styles[cell.status],\n          { [styles.start]: rowIndex === start.x && colIndex === start.y },\n          { [styles.end]: rowIndex === end.x && colIndex === end.y },\n          { [styles.closed]: isClosed },\n          { [styles.checked]: isChecked },\n          { [styles.path]: isPath }\n        )}\n        key={`${rowIndex}-${colIndex}`}\n        onClick={onCellClick(rowIndex, colIndex)}\n        style={{\n          animationDelay: animationOffset\n            ? `${animationOffset * 10}ms`\n            : undefined,\n        }}\n      >\n        {path && (isClosed || isChecked || isPath) ? (\n          <Tooltip title={<TooltipContent cell={path[rowIndex][colIndex]} />}>\n            <div\n              className={styles.gridTooltip}\n              style={{ color: \"transparent\" }}\n            />\n          </Tooltip>\n        ) : null}\n      </td>\n    </>\n  );\n};\nexport default React.memo(GridCell);\n","import React, { useEffect, useState } from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport {\n  selectEnd,\n  selectGrid,\n  selectMode,\n  selectPath,\n  selectStart,\n  setCellAsBlocked,\n  setEnd,\n  setStart,\n} from \"../features/aStarSearch/aStarSearchSlice\";\nimport { Mode } from \"../features/aStarSearch/constants\";\nimport GridCell from \"./GridCell\";\nimport styles from \"./Grid.module.css\";\nconst SearchGrid = (props) => {\n  const grid = useSelector(selectGrid);\n  const end = useSelector(selectEnd);\n  const path = useSelector(selectPath);\n  const start = useSelector(selectStart);\n  const mode = useSelector(selectMode);\n\n  const dispatch = useDispatch();\n\n  const [isPressed, setIsPressed] = useState(false);\n  const onMouseDown = () => setIsPressed(true);\n  const onMouseUp = () => setIsPressed(false);\n\n  useEffect(() => {\n    document.addEventListener(\"mousedown\", onMouseDown);\n    document.addEventListener(\"mouseup\", onMouseUp);\n\n    return () => {\n      document.removeEventListener(\"mousedown\", onMouseDown);\n      document.removeEventListener(\"mouseUp\", onMouseUp);\n    };\n  }, []);\n\n  const onCellClick = (rowIndex, colIndex) => () => {\n    console.log(rowIndex, colIndex);\n    if (mode === Mode.draw) {\n      dispatch(setCellAsBlocked({ x: rowIndex, y: colIndex }));\n    } else if (mode === Mode.setStart) {\n      dispatch(setStart({ x: rowIndex, y: colIndex }));\n    } else if (mode === Mode.setEnd) {\n      dispatch(setEnd({ x: rowIndex, y: colIndex }));\n    }\n  };\n\n  return (\n    <div className={styles.gridRoot}>\n      <table className={styles.gridTable}>\n        <tbody>\n          {grid.map((row, rowIndex) => (\n            <tr key={rowIndex} style={{ border: \"1px solid black\" }}>\n              {row.map((cell, colIndex) => (\n                <GridCell\n                  {...{\n                    key: `${rowIndex} - ${colIndex}`,\n                    cell,\n                    rowIndex,\n                    colIndex,\n                    start,\n                    end,\n                    path,\n                    isPressed,\n                    onCellClick: onCellClick,\n                  }}\n                />\n              ))}\n            </tr>\n          ))}\n        </tbody>\n      </table>\n    </div>\n  );\n};\n\nexport default SearchGrid;\n","import { Card, CardContent, Grid } from \"@material-ui/core\";\nimport React from \"react\";\nimport Controls from \"../../components/Controls\";\nimport SearchGrid from \"../../components/SearchGrid\";\n\nconst AStarSearchComponent = () => {\n  return (\n    <Card>\n      <CardContent>\n        <Grid container spacing={2} justify=\"center\" alignItems=\"center\">\n          <Grid item>\n            <Controls />\n          </Grid>\n          <Grid item>\n            <SearchGrid />\n          </Grid>\n        </Grid>\n      </CardContent>\n    </Card>\n  );\n};\n\nexport default AStarSearchComponent;\n","import React from \"react\";\nimport { Grid } from \"@material-ui/core\";\nimport AStarSearchComponent from \"../../features/aStarSearch/AStarSearch\";\nimport CodeBlock from \"../../components/CodeBlock\";\nimport { snippets } from \"../../snippets\";\n\nconst Lab3 = () => {\n  const tabNameList = [\"Grid Generation\", \"Cost\", \"Path Calculation\"];\n  const tabCodeSnippetList = [\n    snippets.a_star_search_grid_generation,\n    snippets.a_star_search_coord_and_distance,\n    snippets.a_star_search_path_calculation,\n  ];\n\n  return (\n    <Grid item container direction=\"column\" spacing={2}>\n      <Grid item>\n        <AStarSearchComponent />\n      </Grid>\n      <Grid item xs={12} sm={12}>\n        <CodeBlock\n          tabNameList={tabNameList}\n          tabCodeSnippetList={tabCodeSnippetList}\n          language=\"javascript\"\n        />\n      </Grid>\n    </Grid>\n  );\n};\nexport default Lab3;\n"],"sourceRoot":""}