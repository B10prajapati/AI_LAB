{"version":3,"sources":["components/CodeBlock.jsx","snippets/index.js","features/chatbot/ChatbotClass.js","features/chatbot/Chatbot.js","pages/lab5/lab5.js"],"names":["TabPanel","props","children","value","index","other","role","hidden","id","aria-labelledby","CodeBlock","React","useState","setValue","tabNameList","tabCodeSnippetList","language","title","onChange","event","newValue","aria-label","map","name","key","label","a11yProps","codeSnippet","style","dracula","lineProps","wordBreak","whiteSpace","wrapLines","snippets","dfs","bfs","graphClass","water_jug","water_jug_pour_rule","water_jug_rules","water_jug_solution","a_star_search_grid_generation","a_star_search_coord_and_distance","a_star_search_path_calculation","chatbot","chatbot_stem","chatbot_ask","Chatbot","addQuestionsAnswer","questions","answer","question","stemSentence","sentence","natural","PorterStemmer","tokenizeAndStem","ask","toLowerCase","trim","ques","questionWordList","match","Object","keys","quesWordList","push","count","word","includes","Math","max","console","log","bestQuestionMatch","indexOf","listQuestions","questionList","initiateChat","this","c","useStyles","makeStyles","theme","orange","color","palette","getContrastText","deepOrange","backgroundColor","purple","deepPurple","memo","classes","setQuestion","messageHistory","useSelector","selectMessageHistory","dispatch","useDispatch","handleAskQuestion","addQuestion","addAnswer","Grid","container","direction","item","spacing","xs","lg","Card","CardHeader","CardContent","Typography","subheader","avatar","Avatar","className","message","justify","alignItems","align","CardActions","TextField","plaardceholder","variant","e","target","onKeyPress","Button","onClick","Lab5","sm"],"mappings":"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","file":"static/js/10.6850bbf0.chunk.js","sourcesContent":["import { Card, CardContent, CardHeader, Tab, Tabs } from \"@material-ui/core\";\nimport React from \"react\";\nimport SyntaxHighlighter from \"react-syntax-highlighter\";\n\nimport { dracula } from \"react-syntax-highlighter/dist/esm/styles/hljs\";\nimport { PropTypes } from \"prop-types\";\nfunction TabPanel(props) {\n  const { children, value, index, ...other } = props;\n\n  return (\n    <div\n      role=\"tabpanel\"\n      hidden={value !== index}\n      id={`simple-tabpanel-${index}`}\n      aria-labelledby={`simple-tab-${index}`}\n      {...other}\n    >\n      {value === index && <> {children} </>}\n    </div>\n  );\n}\n\nTabPanel.propTypes = {\n  children: PropTypes.node,\n  index: PropTypes.any.isRequired,\n  value: PropTypes.any.isRequired,\n};\nfunction a11yProps(index) {\n  return {\n    id: `simple-tab-${index}`,\n    \"aria-controls\": `simple-tabpanel-${index}`,\n  };\n}\nconst CodeBlock = (props) => {\n  const [value, setValue] = React.useState(0);\n\n  const handleChange = (event, newValue) => {\n    setValue(newValue);\n  };\n\n  const { tabNameList, tabCodeSnippetList, language } = props;\n  return (\n    <Card>\n      <CardHeader title=\"Code\" />\n      <CardContent>\n        <Tabs value={value} onChange={handleChange} aria-label=\"Tree Graph\">\n          {tabNameList.map((name, index) => {\n            return <Tab key={index} label={name} {...a11yProps(index)} />;\n          })}\n        </Tabs>\n        {tabCodeSnippetList.map((codeSnippet, index) => {\n          return (\n            <TabPanel value={value} key={index} index={index}>\n              <SyntaxHighlighter\n                language={language}\n                style={dracula}\n                lineProps={{\n                  style: { wordBreak: \"break-all\", whiteSpace: \"pre-wrap\" },\n                }}\n                wrapLines={true}\n              >\n                {codeSnippet}\n              </SyntaxHighlighter>\n            </TabPanel>\n          );\n        })}\n      </CardContent>\n    </Card>\n  );\n};\n\nexport default CodeBlock;\n","export const snippets = {\n  dfs: `\n  DFS = (key, rev = false) => {\n    let dfs = [];\n    this.stack.push(key);\n    while (1) {\n      if (this.stack.length === 0) {\n        // array empty or does not exist\n        break;\n      }\n      const popped = this.stack.pop();\n\n      dfs.push(popped);\n      if (this.graph[popped] === undefined) {\n      } else {\n        let childData;\n        if (rev) childData = this.graph[popped].slice().reverse();\n        else childData = this.graph[popped];\n        for (let i of childData) {\n          this.stack.push(i);\n        }\n      }\n    }\n    return dfs;\n  };`,\n  bfs: `\n  BFS = (key) => {\n    this.queue.push(key);\n    let bfs = [];\n    while (1) {\n      if (this.queue.length === 0) {\n        // array empty or does not exist\n        break;\n      }\n      const popped = this.queue.shift();\n      bfs.push(popped);\n\n      if (this.graph[popped] === undefined) {\n      } else {\n        const childData = this.graph[popped];\n        for (let i of childData) {\n          this.queue.push(i);\n        }\n      }\n    }\n    return bfs;\n  };`,\n  graphClass: `\n  class Graph {\n    constructor() {\n      this.graph = [];\n      this.stack = [];\n      this.queue = [];\n    }\n    addEdge = (node, newNode) => {\n      if (this.graph[node] === undefined) this.graph[node] = [];\n      this.graph[node].push(newNode);\n    };\n  \n    DFS = (key, rev = false) => {\n      let dfs = [];\n      this.stack.push(key);\n      while (1) {\n        if (this.stack.length === 0) {\n          // array empty or does not exist\n          break;\n        }\n        const popped = this.stack.pop();\n  \n        dfs.push(popped);\n        if (this.graph[popped] === undefined) {\n        } else {\n          let childData;\n          if (rev) childData = this.graph[popped].slice().reverse();\n          else childData = this.graph[popped];\n          for (let i of childData) {\n            this.stack.push(i);\n          }\n        }\n      }\n      return dfs;\n    };\n    BFS = (key) => {\n      this.queue.push(key);\n      let bfs = [];\n      while (1) {\n        if (this.queue.length === 0) {\n          // array empty or does not exist\n          break;\n        }\n        const popped = this.queue.shift();\n        bfs.push(popped);\n  \n        if (this.graph[popped] === undefined) {\n        } else {\n          const childData = this.graph[popped];\n          for (let i of childData) {\n            this.queue.push(i);\n          }\n        }\n      }\n      return bfs;\n    };\n  }\n  `,\n  water_jug: `\n  class WaterJug():\n    def __init__(self,x,y,target):\n        self.capX = x\n        self.capY = y\n        self.x = 0\n        self.y = 0\n        self.targe,end='\\\\n\\\\n\\\\n't = target\n        self.path = []\n        \n    def rule(self,x, d=0):\n        w.printVolume()\n        print('Rule {}'.format(x),end=' ')\n        # fill capX gallon jug completely\n        if(x==1):\n                if self.x<self.capX:\n                    self.x=self.capX\n                print('Fill jugX completely')\n        # fill capY gallon jug completely\n        elif (x==2):\n                if self.y<self.capY:\n                    self.y=self.capY\n                print('Fill jugY completely')\n        # pour some part from x jug\n        elif(x==3):\n                if self.x>0:\n                    self.x= self.x - d\n                print('Pour Some part D from X jug')\n        # pour some part from y jug        \n        elif(x==4):\n                if self.y>0:\n                    self.y = self.y - d\n                \n                print('Pour Some part D from Y jug')\n        # empty jug x        \n        elif(x==5):\n                if self.x>0:\n                    self.x=0\n                print('Empty jugX')\n        # empty jug y        \n        elif(x==6):\n                if self.y>0:\n                    self.y=0\n                print('Empty jugY')\n        # pour water from y jug to fill x jug        \n        elif(x==7):\n                if self.x+self.y < self.capX+self.capY:\n                    self.y= self.y-(self.capX-self.x)\n                    self.x = self.capX\n                print('Pour from jugY to fill jugX')\n        #pour water from x jug to fill y jug\n        elif(x==8):\n                if self.x+self.y < self.capX+self.capY:\n                    self.x=self.x-(self.capY-self.y)\n                    self.y = self.capY\n                print('Pour from jugX to fill jugY')\n        # pour all water from y jug to x jug\n        elif(x==9):\n                if self.x+self.y < self.capX:\n                    self.x= self.x+self.y\n                    self.y=0\n                print('Pour all from jugY to jugX')\n        #pour all water from x jug to y jug\n        elif(x==10):\n                if self.x+self.y < self.capY:\n                    self.x=0\n                    self.y=self.x+self.y     \n                    print('Pour all from jugX to jugY')\n\n        w.printVolume()\n        print('---')\n        self.appendPath()\n             \n    def printVolume(self):\n        print('[JugX={}, JugY={}]'.format(self.x, self.y))\n    \n    # print each state leading upto solution\n    def printPath(self):\n        for state in self.path:\n            if state==self.path[-1]:\n                print(f'[JugX:{state[0]}, JugY:{state[1]}]')\n                continue\n            print(f'[JugX:{state[0]}, JugY:{state[1]}]', end='->')\n    \n    # add new state generated to path\n    def appendPath(self):\n        self.path.append([self.x, self.y])\n    \n    def reset(self):\n        self.x=0\n        self.y=0\n        self.path=[]\n        \n    def pour(self): \n        self.reset()\n        yJug= self.capY\n        xJug=0\n#         self.rule(2)\n        step = 1\n        while ((yJug  is not self.target) and (xJug is not self.target)): \n            print('({},{})'.format(xJug, yJug))\n            \n\n            if(yJug < (self.capX-xJug)):\n                temp = yJug\n#                 self.rule(9)\n            else:\n                temp = (self.capX-xJug)\n#                 self.rule(7)\n            xJug = xJug + temp\n            yJug = yJug - temp\n\n#             temp = min(yJug, self.capX-xJug) \n#             xJug = xJug + temp \n#             yJug = yJug - temp \n\n            print('({},{})'.format(xJug, yJug))\n\n            step =  step + 1\n            if ((yJug == self.target) or (xJug == self.target)): \n                break\n\n            if yJug == 0: \n                yJug = self.capY\n#                 self.rule(2)\n                step =  step + 1\n\n            if xJug == self.capX: \n                xJug = 0\n#                 self.rule(5)\n                step =  step + 1\n    \n    # Solve using rules\n    def pourRule(self):\n        self.reset()\n        self.rule(2)\n        step = 1\n        while(1):\n            if(self.y==self.target or self.x==self.target):\n                break\n            \n            if(self.y < (self.capX-self.x)):\n                self.rule(9)\n            else:\n                self.rule(7)\n            \n            step=step+1\n            if(self.y==self.target or self.x==self.target):\n                break\n            \n            if self.y==0:\n                self.rule(2)\n                step = step + 1\n            \n            if self.x==self.capX:\n                self.rule(5)\n                step = step+1\n        return step \n\n    # Reverse the capacity of jugs\n    def reverseJugCapacity(self):\n        self.capX, self.capY = self.capY, self.capX\n    \n    # Solve  for both x,y and y,x conditions \n    def solve(self):\n        print(f'With JugXCapacity {self.capX} and JugYCapacity {self.capY}',end='\\\\n\\\\n\\\\n')\n        print(f'Total steps to solve : {self.pourRule()}',end='\\\\n\\\\n')\n        self.printPath()\n        print('*'*100)\n        print(f'With JugXCapacity {self.capX} and JugYCapacity {self.capY}',end='\\\\n\\\\n\\\\n')\n        self.reverseJugCapacity()\n        print(f'Total steps to solve : {self.pourRule()}',end='\\\\n\\\\n')\n        self.printPath()\n  `,\n  water_jug_pour_rule: `\n  # Solve using rules\n  def pourRule(self):\n      self.reset()\n      self.rule(2)\n      step = 1\n      while(1):\n          if(self.y==self.target or self.x==self.target):\n              break\n          \n          if(self.y < (self.capX-self.x)):\n              self.rule(9)\n          else:\n              self.rule(7)\n          \n          step=step+1\n          if(self.y==self.target or self.x==self.target):\n              break\n          \n          if self.y==0:\n              self.rule(2)\n              step = step + 1\n          \n          if self.x==self.capX:\n              self.rule(5)\n              step = step+1\n      return step \n  `,\n  water_jug_rules: `\n  def rule(self,x, d=0):\n    w.printVolume()\n    print('Rule {}'.format(x),end=' ')\n    # fill capX gallon jug completely\n    if(x==1):\n            if self.x<self.capX:\n                self.x=self.capX\n            print('Fill jugX completely')\n    # fill capY gallon jug completely\n    elif (x==2):\n            if self.y<self.capY:\n                self.y=self.capY\n            print('Fill jugY completely')\n    # pour some part from x jug\n    elif(x==3):\n            if self.x>0:\n                self.x= self.x - d\n            print('Pour Some part D from X jug')\n    # pour some part from y jug        \n    elif(x==4):\n            if self.y>0:\n                self.y = self.y - d\n            \n            print('Pour Some part D from Y jug')\n    # empty jug x        \n    elif(x==5):\n            if self.x>0:\n                self.x=0\n            print('Empty jugX')\n    # empty jug y        \n    elif(x==6):\n            if self.y>0:\n                self.y=0\n            print('Empty jugY')\n    # pour water from y jug to fill x jug        \n    elif(x==7):\n            if self.x+self.y < self.capX+self.capY:\n                self.y= self.y-(self.capX-self.x)\n                self.x = self.capX\n            print('Pour from jugY to fill jugX')\n    #pour water from x jug to fill y jug\n    elif(x==8):\n            if self.x+self.y < self.capX+self.capY:\n                self.x=self.x-(self.capY-self.y)\n                self.y = self.capY\n            print('Pour from jugX to fill jugY')\n    # pour all water from y jug to x jug\n    elif(x==9):\n            if self.x+self.y < self.capX:\n                self.x= self.x+self.y\n                self.y=0\n            print('Pour all from jugY to jugX')\n    #pour all water from x jug to y jug\n    elif(x==10):\n            if self.x+self.y < self.capY:\n                self.x=0\n                self.y=self.x+self.y     \n                print('Pour all from jugX to jugY')\n\n    w.printVolume()\n    print('---')\n    self.appendPath()\n  `,\n  water_jug_solution: `\n  w = WaterJug(5,3,4)\n  w.solve()\n  \n  OUTPUT:\n    With JugXCapacity 5 and JugYCapacity 3\n\n\n    [JugX=0, JugY=0]\n    Rule 2 Fill jugY completely\n    [JugX=0, JugY=3]\n    ---\n    [JugX=0, JugY=3]\n    Rule 9 Pour all from jugY to jugX\n    [JugX=3, JugY=0]\n    ---\n    [JugX=3, JugY=0]\n    Rule 2 Fill jugY completely\n    [JugX=3, JugY=3]\n    ---\n    [JugX=3, JugY=3]\n    Rule 7 Pour from jugY to fill jugX\n    [JugX=5, JugY=1]\n    ---\n    [JugX=5, JugY=1]\n    Rule 5 Empty jugX\n    [JugX=0, JugY=1]\n    ---\n    [JugX=0, JugY=1]\n    Rule 9 Pour all from jugY to jugX\n    [JugX=1, JugY=0]\n    ---\n    [JugX=1, JugY=0]\n    Rule 2 Fill jugY completely\n    [JugX=1, JugY=3]\n    ---\n    [JugX=1, JugY=3]\n    Rule 9 Pour all from jugY to jugX\n    [JugX=4, JugY=0]\n    ---\n    Total steps to solve : 8\n\n    [JugX:0, JugY:3]-> [JugX:3, JugY:0]-> [JugX:3, JugY:3]-> [JugX:5, JugY:1]->\n    [JugX:0, JugY:1]-> [JugX:1, JugY:0]-> [JugX:1, JugY:3]-> [JugX:4, JugY:0]\n    *****************************************************\n    With JugXCapacity 5 and JugYCapacity 3\n\n\n    [JugX=0, JugY=0]\n    Rule 2 Fill jugY completely\n    [JugX=0, JugY=5]\n    ---\n    [JugX=0, JugY=5]\n    Rule 7 Pour from jugY to fill jugX\n    [JugX=3, JugY=2]\n    ---\n    [JugX=3, JugY=2]\n    Rule 5 Empty jugX\n    [JugX=0, JugY=2]\n    ---\n    [JugX=0, JugY=2]\n    Rule 9 Pour all from jugY to jugX\n    [JugX=2, JugY=0]\n    ---\n    [JugX=2, JugY=0]\n    Rule 2 Fill jugY completely\n    [JugX=2, JugY=5]\n    ---\n    [JugX=2, JugY=5]\n    Rule 7 Pour from jugY to fill jugX\n    [JugX=3, JugY=4]\n    ---\n    Total steps to solve : 6\n\n    [JugX:0, JugY:5]->[JugX:3, JugY:2]->[JugX:0, JugY:2]\n    ->[JugX:2, JugY:0]->[JugX:2, JugY:5]->[JugX:3, JugY:4]\n\n  `,\n  a_star_search_grid_generation: `\n  const generateGrid = (numbeOfRows, numberOfColumns, value) => {\n    return range(numbeOfRows).map((x) =>\n      range(numberOfColumns).map((y) => ({\n        ...value,\n        x,\n        y,\n      }))\n    );\n  };\n  `,\n  a_star_search_coord_and_distance: `\n  const coordinatesToCheck = [\n    { y: 0, x: -1 },\n    { y: 1, x: -1 },\n    { y: 1, x: 0 },\n    { y: 1, x: 1 },\n    { y: 0, x: 1 },\n    { y: -1, x: 1 },\n    { y: -1, x: 0 },\n    { y: -1, x: -1 },\n  ];\n  \n  const getDistance = (a, b) => {\n    const colOffset = Math.abs(a.y - b.y);\n    const rowOffset = Math.abs(a.x - b.x);\n    const numberOfStraightSegments = Math.abs(colOffset - rowOffset);\n    const numberOfDiagonalSegments =\n      Math.max(colOffset, rowOffset) - numberOfStraightSegments;\n  \n    return numberOfStraightSegments * 10 + numberOfDiagonalSegments * 14; // 14 ~ 10 * sqrt(2)\n  };  \n  `,\n\n  a_star_search_path_calculation: `  \n  export const computePath = (mainGrid, start, end) => {\n    const gridLength = mainGrid.length;\n\n    let counter = 0;\n    let openList = [];\n    const grid = generateGrid(gridLength, gridLength, {\n      fCost: 0,\n      gCost: 0,\n      hCost: 0,\n      parent: undefined,\n      isClosed: false,\n      isPath: false,\n      counter: 0,\n      x: 0,\n      y: 0,\n    });\n    openList.push(grid[start.x][start.y]);\n\n    while (openList.length > 0) {\n      const currentCell = minBy(openList, (c) => c.fCost);\n\n      if (!currentCell) {\n        // no path found\n        return grid;\n      }\n\n      if (currentCell.x === end.x && currentCell.y === end.y) {\n        let curr = currentCell;\n\n        while (curr.parent) {\n          grid[curr.x][curr.y].isPath = true;\n          curr = curr.parent;\n        }\n\n        return grid;\n      }\n\n      remove(openList, (c) => c.x === currentCell.x && c.y === currentCell.y);\n      currentCell.isClosed = true;\n      // eslint-disable-next-line no-loop-func\n      coordinatesToCheck.forEach((coordinatesToCheck) => {\n        const { x, y } = {\n          x: currentCell.x + coordinatesToCheck.x,\n          y: currentCell.y + coordinatesToCheck.y,\n        };\n\n        if (\n          x < 0 ||\n          x >= gridLength ||\n          y < 0 ||\n          y >= gridLength ||\n          (start.x === x && start.y === y) ||\n          grid[x][y].isClosed ||\n          mainGrid[x][y].status === \"blocked\"\n        ) {\n          return;\n        }\n\n        const neighbourCell = grid[x][y];\n\n        const gCost = currentCell.gCost + getDistance(currentCell, neighbourCell);\n        let gCostIsBest = false;\n\n        if (!openList.find((c) => c.x === x && c.y === y)) {\n          gCostIsBest = true;\n          neighbourCell.hCost = getDistance(neighbourCell, end);\n          openList.push(neighbourCell);\n        } else if (gCost < neighbourCell.gCost) {\n          gCostIsBest = true;\n        }\n\n        if (gCostIsBest) {\n          neighbourCell.parent = currentCell;\n          neighbourCell.gCost = gCost;\n          neighbourCell.fCost = neighbourCell.gCost + neighbourCell.hCost;\n          counter = counter + 1;\n          neighbourCell.counter = counter;\n        }\n      });\n    }\n    // No path found\n    return grid;\n  };\n  `,\n  chatbot: `\n  import natural from \"natural\";\n\n  class Chatbot {  \n    constructor(name = \"Agent\") {\n      this.name = name;\n      this.questions = {};\n    }\n  \n    addQuestionsAnswer = (questions, answer) => {\n      let question;\n      for (question of questions) {\n        this.questions[question] = answer;\n      }\n    };\n  \n    //  stem words (fast but abstract words)\n    stemSentence = (sentence) => {\n      return natural.PorterStemmer.tokenizeAndStem(sentence);\n    };\n  \n    ask = (question) => {\n      question = question.toLowerCase().trim();\n      const questionWordList = this.stemSentence(question);\n      let index = 0;\n      let match = [];\n      //console.log(questionWordList);\n      let ques;\n      for (ques of Object.keys(this.questions)) {\n        ques = ques.toLowerCase().trim();\n        //console.log(ques);\n        const quesWordList = this.stemSentence(ques);\n        // console.log(quesWordList);\n        match.push(0);\n        let count = 0;\n        let word;\n        for (word of quesWordList) {\n          count += 1;\n          if (questionWordList.includes(word)) {\n            match[index] += 1;\n          }\n        }\n        match[index] = match[index] / Math.max(count, 1);\n        index += 1;\n        //  console.log(ques)\n        //  console.log(question)\n        // if (ques.toLowerCase().trim() === question) {\n        //   console.log(match);\n  \n        //   console.log(match.index(match.max));\n        //   return this.questions[ques];\n        // }\n      }\n      console.log(match);\n      const max = Math.max(...match);\n      console.log(max);\n      if (max >= 0.3) {\n        //  [match.index(max(match))]\n        const bestQuestionMatch = Object.keys(this.questions)[match.indexOf(max)];\n        return this.questions[bestQuestionMatch];\n      }\n      return \"I did not understand the question!\";\n    };\n  \n    listQuestions = () => {\n      var question;\n      let questionList = [];\n      for (question of Object.keys(this.questions)) {\n        // console.log(question);\n        questionList.push(question);\n      }\n      // console.log(questionList);\n      return questionList;\n    };\n  \n    initiateChat = () => {\n      // console.log(\"Chat with {this.name}\");\n      // console.log(\"Availabe questions for {this.name}\");\n      this.listQuestions();\n  \n      while (1) {\n        //var question = prompt(\"Enter question for {this.name} \\n\");\n        const question = \"Hi\";\n        if (\n          [\n            \"quit\",\n            \"exit\",\n            \"close\",\n            \"stop\",\n            \"end\",\n            \".\",\n            \"annihilate\",\n            \"disconnect\",\n          ].includes(question)\n        ) {\n          break;\n        }\n        // console.log(\"{this.ask(question)}\");\n      }\n    };\n  }   \n  `,\n  chatbot_stem: `\n  //  stem words (fast but abstract words)\n  stemSentence = (sentence) => {\n    return natural.PorterStemmer.tokenizeAndStem(sentence);\n  };\n  `,\n  chatbot_ask: `\n  ask = (question) => {\n    question = question.toLowerCase().trim();\n    const questionWordList = this.stemSentence(question);\n    let index = 0;\n    let match = [];\n    //console.log(questionWordList);\n    let ques;\n    for (ques of Object.keys(this.questions)) {\n      ques = ques.toLowerCase().trim();\n      //console.log(ques);\n      const quesWordList = this.stemSentence(ques);\n      // console.log(quesWordList);\n      match.push(0);\n      let count = 0;\n      let word;\n      for (word of quesWordList) {\n        count += 1;\n        if (questionWordList.includes(word)) {\n          match[index] += 1;\n        }\n      }\n      match[index] = match[index] / Math.max(count, 1);\n      index += 1;\n      //  console.log(ques)\n      //  console.log(question)\n      // if (ques.toLowerCase().trim() === question) {\n      //   console.log(match);\n\n      //   console.log(match.index(match.max));\n      //   return this.questions[ques];\n      // }\n    }\n    console.log(match);\n    const max = Math.max(...match);\n    console.log(max);\n    if (max >= 0.3) {\n      //  [match.index(max(match))]\n      const bestQuestionMatch = Object.keys(this.questions)[match.indexOf(max)];\n      return this.questions[bestQuestionMatch];\n    }\n    return \"I did not understand the question!\";\n  };\n  `,\n};\n","import natural from \"natural\";\n\nclass Chatbot {\n  constructor(name = \"Agent\") {\n    this.name = name;\n    this.questions = {};\n  }\n\n  addQuestionsAnswer = (questions, answer) => {\n    let question;\n\n    for (question of questions) {\n      this.questions[question] = answer;\n    }\n  };\n\n  //  stem words (fast but abstract words)\n  stemSentence = (sentence) => {\n    return natural.PorterStemmer.tokenizeAndStem(sentence);\n  };\n\n  ask = (question) => {\n    question = question.toLowerCase().trim();\n    const questionWordList = this.stemSentence(question);\n    let index = 0;\n    let match = [];\n    //console.log(questionWordList);\n\n    let ques;\n    for (ques of Object.keys(this.questions)) {\n      ques = ques.toLowerCase().trim();\n      //console.log(ques);\n      const quesWordList = this.stemSentence(ques);\n      // console.log(quesWordList);\n      match.push(0);\n      let count = 0;\n\n      let word;\n      for (word of quesWordList) {\n        count += 1;\n        if (questionWordList.includes(word)) {\n          match[index] += 1;\n        }\n      }\n      match[index] = match[index] / Math.max(count, 1);\n      index += 1;\n      //  console.log(ques)\n      //  console.log(question)\n      // if (ques.toLowerCase().trim() === question) {\n      //   console.log(match);\n\n      //   console.log(match.index(match.max));\n      //   return this.questions[ques];\n      // }\n    }\n\n    console.log(match);\n    const max = Math.max(...match);\n    console.log(max);\n    if (max >= 0.3) {\n      //  [match.index(max(match))]\n      const bestQuestionMatch = Object.keys(this.questions)[match.indexOf(max)];\n      return this.questions[bestQuestionMatch];\n    }\n\n    return \"I did not understand the question!\";\n  };\n\n  listQuestions = () => {\n    var question;\n    let questionList = [];\n    for (question of Object.keys(this.questions)) {\n      // console.log(question);\n      questionList.push(question);\n    }\n    // console.log(questionList);\n    return questionList;\n  };\n\n  initiateChat = () => {\n    // console.log(\"Chat with {this.name}\");\n    // console.log(\"Availabe questions for {this.name}\");\n    this.listQuestions();\n\n    while (1) {\n      //var question = prompt(\"Enter question for {this.name} \\n\");\n      const question = \"Hi\";\n      if (\n        [\n          \"quit\",\n          \"exit\",\n          \"close\",\n          \"stop\",\n          \"end\",\n          \".\",\n          \"annihilate\",\n          \"disconnect\",\n        ].includes(question)\n      ) {\n        break;\n      }\n\n      // console.log(\"{this.ask(question)}\");\n    }\n  };\n}\n\nexport default Chatbot;\n","import {\n  Avatar,\n  Button,\n  Card,\n  CardActions,\n  CardContent,\n  CardHeader,\n  Grid,\n  makeStyles,\n  TextField,\n  Typography,\n} from \"@material-ui/core\";\nimport { deepOrange, deepPurple } from \"@material-ui/core/colors\";\nimport React, { useState } from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport Chatbot from \"./ChatbotClass\";\nimport { addAnswer, addQuestion, selectMessageHistory } from \"./chatbotSlice\";\n\nconst c = new Chatbot();\n\nconst addAllQuestions = () => {\n  c.addQuestionsAnswer(\n    [\"Hello\", \"Hi\", \"Hey\"],\n    \"Hi! Welcome to Khwopa Q&A. How Can I Help You?\"\n  );\n\n  c.addQuestionsAnswer(\n    [\"Are KhEC & KhCE same?\"],\n    \"No, Khwopa College of Engineering (KhCE) is affiliated to Tribhuvan University and Khwopa Engineering College (KhEC) is affiliated to Purbanchal University.\"\n  );\n\n  c.addQuestionsAnswer(\n    [\"Can a student be awarded with more than one scholarship?\"],\n    \"No. But, the candidate can choose the better one for him/her. \"\n  );\n  c.addQuestionsAnswer(\n    [\"Is there hostel facility in college?\"],\n    \"No, there is not such facility. But there are several private hostels nearby.\"\n  );\n  c.addQuestionsAnswer([\"Fee Structure\"], \"\");\n\n  c.addQuestionsAnswer(\n    [\"Does the college conduct any career based counselling programs?\"],\n    \"Yes, counselling programs are conducted from time to time. Experienced professionals in the respective fields are invited for their valuable suggestions and sharing their working experiences with the students.\"\n  );\n  c.addQuestionsAnswer(\n    [\n      \"How are students involved in the practical field of their respective courses\",\n    ],\n    \"College organizes different expos and exhibition at certain intervals for improving students' practical skills in their fields. Students also get involved and participate in different competitions organized by various organizations of their respective fields.\"\n  );\n  c.addQuestionsAnswer(\n    [\"Can I get extra classes in college?\"],\n    \"Yes, it is possible to get extra classes if requested by students in needy time.\"\n  );\n  c.addQuestionsAnswer(\n    [\"Is parent meeting conducted timely?\"],\n    \"Yes, it is conducted timely on the requirement basis.\"\n  );\n  c.addQuestionsAnswer(\n    [\"When deposit can be refunded?\"],\n    \"Deposits can only be refunded after completing all the four years courses.\"\n  );\n  c.addQuestionsAnswer(\n    [\"Does college provide any scholarship?\"],\n    \"College provides full scholarship for the applicants of each program with minimun 75% in +2 science or I.Sc., or Diploma in engineering and scoring the highest marks in the entrance exam.Scholarship may be granted to economically needy, diligent and disciplined student. On the basis of the marks secured in semester examination, college will provide scholarships of 100%, 50% and 25%.\"\n  );\n  c.addQuestionsAnswer(\n    [\"What extra curriculum activities are conducted in college?\"],\n    \"Various extra curriculur activities and sports competitions are conducted in college like chess, table tennis, badminton and football competition \"\n  );\n  c.addQuestionsAnswer(\n    [\"Is college uniform compulsory?\"],\n    \"Yes, it is compulsory to be in uniform. Students without uniform are not allowed to sit in the class. There is no excuse for not being in uniform.\"\n  );\n  c.addQuestionsAnswer(\n    [\"What is the procedure for interview?\"],\n    \"Some oral exams are conducted in the interview. You might need to solve some written problems depending on your academic performance or the performance during the interview.\"\n  );\n  c.addQuestionsAnswer(\n    [\"What is the fee structure?\"],\n    \"It’s Rs.5,86,500 for Bachelor in Electrical, Rs.5,86,500 for Bachelor in Computer and Rs.6,01,500 for Bachelor in Civil.\"\n  );\n  c.addQuestionsAnswer(\n    [\"Can I get online form facility?\"],\n    \"Yes, you can fill up online form.\"\n  );\n  c.addQuestionsAnswer(\n    [\"What is the admission procedure?\"],\n    \"Student must fill up online entrance form.He/She will be selected according to their rank in IOE exam. After selection he/ she must attend the college interview. After students are approved from interview, Firstly he/she can visit college reception to know about the requirements for admission, fee structures and documents required etc.\"\n  );\n  c.addQuestionsAnswer(\n    [\"What courses are available now?\"],\n    \"Bachelor in  Civil Engineering,\\nBachelor in  Computer Engineering,\\nBachelor in  Electrical Engineering\"\n  );\n  c.addQuestionsAnswer(\n    [\"Why is it important to attend my college classes?\"],\n    \"Aside from the fact that you are paying for it, showing up for class will give you an immediate advantage in learning what your professors think are important, and what is most likely to show up on those final exams. Class is also where you get the chance to meet new people, form study groups, etc.\"\n  );\n};\n\naddAllQuestions();\nconst questionList = c.listQuestions();\n\nconst useStyles = makeStyles((theme) => ({\n  orange: {\n    color: theme.palette.getContrastText(deepOrange[500]),\n    backgroundColor: deepOrange[500],\n  },\n  purple: {\n    color: theme.palette.getContrastText(deepPurple[500]),\n    backgroundColor: deepPurple[500],\n  },\n}));\n\nconst ChatbotComponent = () => {\n  const classes = useStyles();\n  const [question, setQuestion] = useState(\"\");\n  const messageHistory = useSelector(selectMessageHistory);\n  const dispatch = useDispatch();\n\n  const handleAskQuestion = () => {\n    dispatch(addQuestion({ question: question }));\n\n    dispatch(addAnswer({ answer: c.ask(question) }));\n    setQuestion(\"\");\n  };\n\n  return (\n    <Grid container direction=\"column\">\n      <Grid item container>\n        <Grid item container spacing={2}>\n          <Grid item xs={12} lg={6}>\n            <Card>\n              <CardHeader title=\"Questions For Chatbot\" />\n              <CardContent>\n                {questionList.map((question, index) => {\n                  return <Typography key={index}>{question}</Typography>;\n                })}\n              </CardContent>\n            </Card>\n          </Grid>\n          <Grid item xs={12} lg={6}>\n            <Card>\n              <CardHeader\n                title=\"ChatBot Messaging\"\n                subheader=\"Chat with Us\"\n                avatar={\n                  <Avatar aria-label=\"messenger\" className={classes.orange}>\n                    C\n                  </Avatar>\n                }\n              />\n              <CardContent>\n                <Grid item container spacing={4} xs={12}>\n                  {messageHistory.map((message, index) => {\n                    return index % 2 !== 0 ? (\n                      <Grid\n                        item\n                        key={index}\n                        container\n                        direction=\"row\"\n                        justify=\"flex-start\"\n                        alignItems=\"center\"\n                        xs={12}\n                      >\n                        <Grid item xs={2}>\n                          <Avatar className={classes.orange}>C</Avatar>\n                        </Grid>\n                        <Grid item xs={10}>\n                          <Typography align=\"left\">{message}</Typography>\n                        </Grid>\n                      </Grid>\n                    ) : (\n                      <Grid\n                        xs={12}\n                        spacing={2}\n                        item\n                        key={index}\n                        container\n                        direction=\"row\"\n                        justify=\"flex-end\"\n                        alignItems=\"center\"\n                      >\n                        <Grid item xs={10}>\n                          <Typography align=\"right\">{message}</Typography>\n                        </Grid>\n                        <Grid item xs={2}>\n                          <Avatar align=\"right\" className={classes.purple}>\n                            U\n                          </Avatar>\n                        </Grid>\n                      </Grid>\n                    );\n                  })}\n                </Grid>\n              </CardContent>\n              <CardActions>\n                <TextField\n                  label=\"Message\"\n                  plaardceholder=\"Enter question\"\n                  variant=\"outlined\"\n                  aria-label=\"Node name\"\n                  value={question}\n                  onChange={(e) => setQuestion(e.target.value)}\n                  onKeyPress={(e) => {\n                    if (e.key === \"Enter\") handleAskQuestion();\n                  }}\n                />\n                <Button variant=\"outlined\" onClick={handleAskQuestion}>\n                  Ask Question\n                </Button>\n              </CardActions>\n            </Card>\n          </Grid>\n        </Grid>\n      </Grid>\n    </Grid>\n  );\n};\n\nexport default React.memo(ChatbotComponent);\n","import React from \"react\";\nimport { Grid } from \"@material-ui/core\";\nimport ChatbotComponent from \"../../features/chatbot/Chatbot\";\nimport CodeBlock from \"../../components/CodeBlock\";\nimport { snippets } from \"../../snippets\";\n\nconst Lab5 = () => {\n  const tabNameList = [\"STEM\", \"ASK\", \"ChatBot Class\"];\n  const tabCodeSnippetList = [\n    snippets.chatbot_stem,\n    snippets.chatbot_ask,\n    snippets.chatbot,\n  ];\n\n  return (\n    <Grid item container direction=\"column\" spacing={2}>\n      <Grid item>\n        <ChatbotComponent />\n      </Grid>\n      <Grid item xs={12} sm={12}>\n        <CodeBlock\n          tabNameList={tabNameList}\n          tabCodeSnippetList={tabCodeSnippetList}\n          language=\"javascript\"\n        />\n      </Grid>\n    </Grid>\n  );\n};\nexport default Lab5;\n"],"sourceRoot":""}