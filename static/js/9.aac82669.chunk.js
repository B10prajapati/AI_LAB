(this.webpackJsonpai_lab=this.webpackJsonpai_lab||[]).push([[9],{201:function(e,n,t){"use strict";var a=t(73),l=t(234),s=t(720),r=t(734),o=t(721),i=t(746),u=t(736),c=t(0),f=t.n(c),g=t(744),p=t(737);function m(e){var n=e.children,t=e.value,a=e.index,s=Object(l.a)(e,["children","value","index"]);return f.a.createElement("div",Object.assign({role:"tabpanel",hidden:t!==a,id:"simple-tabpanel-".concat(a),"aria-labelledby":"simple-tab-".concat(a)},s),t===a&&f.a.createElement(f.a.Fragment,null," ",n," "))}n.a=function(e){var n=f.a.useState(0),t=Object(a.a)(n,2),l=t[0],c=t[1],h=e.tabNameList,d=e.tabCodeSnippetList,y=e.language;return f.a.createElement(s.a,null,f.a.createElement(r.a,{title:"Code"}),f.a.createElement(o.a,null,f.a.createElement(i.a,{value:l,onChange:function(e,n){c(n)},"aria-label":"Tree Graph"},h.map((function(e,n){return f.a.createElement(u.a,Object.assign({key:n,label:e},function(e){return{id:"simple-tab-".concat(e),"aria-controls":"simple-tabpanel-".concat(e)}}(n)))}))),d.map((function(e,n){return f.a.createElement(m,{value:l,key:n,index:n},f.a.createElement(g.a,{language:y,style:p.a,lineProps:{style:{wordBreak:"break-all",whiteSpace:"pre-wrap"}},wrapLines:!0},e))}))))}},202:function(e,n,t){"use strict";t.d(n,"a",(function(){return a}));var a={dfs:"\n  DFS = (key, rev = false) => {\n    let dfs = [];\n    this.stack.push(key);\n    while (1) {\n      if (this.stack.length === 0) {\n        // array empty or does not exist\n        break;\n      }\n      const popped = this.stack.pop();\n\n      dfs.push(popped);\n      if (this.graph[popped] === undefined) {\n      } else {\n        let childData;\n        if (rev) childData = this.graph[popped].slice().reverse();\n        else childData = this.graph[popped];\n        for (let i of childData) {\n          this.stack.push(i);\n        }\n      }\n    }\n    return dfs;\n  };",bfs:"\n  BFS = (key) => {\n    this.queue.push(key);\n    let bfs = [];\n    while (1) {\n      if (this.queue.length === 0) {\n        // array empty or does not exist\n        break;\n      }\n      const popped = this.queue.shift();\n      bfs.push(popped);\n\n      if (this.graph[popped] === undefined) {\n      } else {\n        const childData = this.graph[popped];\n        for (let i of childData) {\n          this.queue.push(i);\n        }\n      }\n    }\n    return bfs;\n  };",graphClass:"\n  class Graph {\n    constructor() {\n      this.graph = [];\n      this.stack = [];\n      this.queue = [];\n    }\n    addEdge = (node, newNode) => {\n      if (this.graph[node] === undefined) this.graph[node] = [];\n      this.graph[node].push(newNode);\n    };\n  \n    DFS = (key, rev = false) => {\n      let dfs = [];\n      this.stack.push(key);\n      while (1) {\n        if (this.stack.length === 0) {\n          // array empty or does not exist\n          break;\n        }\n        const popped = this.stack.pop();\n  \n        dfs.push(popped);\n        if (this.graph[popped] === undefined) {\n        } else {\n          let childData;\n          if (rev) childData = this.graph[popped].slice().reverse();\n          else childData = this.graph[popped];\n          for (let i of childData) {\n            this.stack.push(i);\n          }\n        }\n      }\n      return dfs;\n    };\n    BFS = (key) => {\n      this.queue.push(key);\n      let bfs = [];\n      while (1) {\n        if (this.queue.length === 0) {\n          // array empty or does not exist\n          break;\n        }\n        const popped = this.queue.shift();\n        bfs.push(popped);\n  \n        if (this.graph[popped] === undefined) {\n        } else {\n          const childData = this.graph[popped];\n          for (let i of childData) {\n            this.queue.push(i);\n          }\n        }\n      }\n      return bfs;\n    };\n  }\n  ",water_jug:"\n  class WaterJug():\n    def __init__(self,x,y,target):\n        self.capX = x\n        self.capY = y\n        self.x = 0\n        self.y = 0\n        self.targe,end='\\n\\n\\n't = target\n        self.path = []\n        \n    def rule(self,x, d=0):\n        w.printVolume()\n        print('Rule {}'.format(x),end=' ')\n        # fill capX gallon jug completely\n        if(x==1):\n                if self.x<self.capX:\n                    self.x=self.capX\n                print('Fill jugX completely')\n        # fill capY gallon jug completely\n        elif (x==2):\n                if self.y<self.capY:\n                    self.y=self.capY\n                print('Fill jugY completely')\n        # pour some part from x jug\n        elif(x==3):\n                if self.x>0:\n                    self.x= self.x - d\n                print('Pour Some part D from X jug')\n        # pour some part from y jug        \n        elif(x==4):\n                if self.y>0:\n                    self.y = self.y - d\n                \n                print('Pour Some part D from Y jug')\n        # empty jug x        \n        elif(x==5):\n                if self.x>0:\n                    self.x=0\n                print('Empty jugX')\n        # empty jug y        \n        elif(x==6):\n                if self.y>0:\n                    self.y=0\n                print('Empty jugY')\n        # pour water from y jug to fill x jug        \n        elif(x==7):\n                if self.x+self.y < self.capX+self.capY:\n                    self.y= self.y-(self.capX-self.x)\n                    self.x = self.capX\n                print('Pour from jugY to fill jugX')\n        #pour water from x jug to fill y jug\n        elif(x==8):\n                if self.x+self.y < self.capX+self.capY:\n                    self.x=self.x-(self.capY-self.y)\n                    self.y = self.capY\n                print('Pour from jugX to fill jugY')\n        # pour all water from y jug to x jug\n        elif(x==9):\n                if self.x+self.y < self.capX:\n                    self.x= self.x+self.y\n                    self.y=0\n                print('Pour all from jugY to jugX')\n        #pour all water from x jug to y jug\n        elif(x==10):\n                if self.x+self.y < self.capY:\n                    self.x=0\n                    self.y=self.x+self.y     \n                    print('Pour all from jugX to jugY')\n\n        w.printVolume()\n        print('---')\n        self.appendPath()\n             \n    def printVolume(self):\n        print('[JugX={}, JugY={}]'.format(self.x, self.y))\n    \n    # print each state leading upto solution\n    def printPath(self):\n        for state in self.path:\n            if state==self.path[-1]:\n                print(f'[JugX:{state[0]}, JugY:{state[1]}]')\n                continue\n            print(f'[JugX:{state[0]}, JugY:{state[1]}]', end='->')\n    \n    # add new state generated to path\n    def appendPath(self):\n        self.path.append([self.x, self.y])\n    \n    def reset(self):\n        self.x=0\n        self.y=0\n        self.path=[]\n        \n    def pour(self): \n        self.reset()\n        yJug= self.capY\n        xJug=0\n#         self.rule(2)\n        step = 1\n        while ((yJug  is not self.target) and (xJug is not self.target)): \n            print('({},{})'.format(xJug, yJug))\n            \n\n            if(yJug < (self.capX-xJug)):\n                temp = yJug\n#                 self.rule(9)\n            else:\n                temp = (self.capX-xJug)\n#                 self.rule(7)\n            xJug = xJug + temp\n            yJug = yJug - temp\n\n#             temp = min(yJug, self.capX-xJug) \n#             xJug = xJug + temp \n#             yJug = yJug - temp \n\n            print('({},{})'.format(xJug, yJug))\n\n            step =  step + 1\n            if ((yJug == self.target) or (xJug == self.target)): \n                break\n\n            if yJug == 0: \n                yJug = self.capY\n#                 self.rule(2)\n                step =  step + 1\n\n            if xJug == self.capX: \n                xJug = 0\n#                 self.rule(5)\n                step =  step + 1\n    \n    # Solve using rules\n    def pourRule(self):\n        self.reset()\n        self.rule(2)\n        step = 1\n        while(1):\n            if(self.y==self.target or self.x==self.target):\n                break\n            \n            if(self.y < (self.capX-self.x)):\n                self.rule(9)\n            else:\n                self.rule(7)\n            \n            step=step+1\n            if(self.y==self.target or self.x==self.target):\n                break\n            \n            if self.y==0:\n                self.rule(2)\n                step = step + 1\n            \n            if self.x==self.capX:\n                self.rule(5)\n                step = step+1\n        return step \n\n    # Reverse the capacity of jugs\n    def reverseJugCapacity(self):\n        self.capX, self.capY = self.capY, self.capX\n    \n    # Solve  for both x,y and y,x conditions \n    def solve(self):\n        print(f'With JugXCapacity {self.capX} and JugYCapacity {self.capY}',end='\\n\\n\\n')\n        print(f'Total steps to solve : {self.pourRule()}',end='\\n\\n')\n        self.printPath()\n        print('*'*100)\n        print(f'With JugXCapacity {self.capX} and JugYCapacity {self.capY}',end='\\n\\n\\n')\n        self.reverseJugCapacity()\n        print(f'Total steps to solve : {self.pourRule()}',end='\\n\\n')\n        self.printPath()\n  ",water_jug_pour_rule:"\n  # Solve using rules\n  def pourRule(self):\n      self.reset()\n      self.rule(2)\n      step = 1\n      while(1):\n          if(self.y==self.target or self.x==self.target):\n              break\n          \n          if(self.y < (self.capX-self.x)):\n              self.rule(9)\n          else:\n              self.rule(7)\n          \n          step=step+1\n          if(self.y==self.target or self.x==self.target):\n              break\n          \n          if self.y==0:\n              self.rule(2)\n              step = step + 1\n          \n          if self.x==self.capX:\n              self.rule(5)\n              step = step+1\n      return step \n  ",water_jug_rules:"\n  def rule(self,x, d=0):\n    w.printVolume()\n    print('Rule {}'.format(x),end=' ')\n    # fill capX gallon jug completely\n    if(x==1):\n            if self.x<self.capX:\n                self.x=self.capX\n            print('Fill jugX completely')\n    # fill capY gallon jug completely\n    elif (x==2):\n            if self.y<self.capY:\n                self.y=self.capY\n            print('Fill jugY completely')\n    # pour some part from x jug\n    elif(x==3):\n            if self.x>0:\n                self.x= self.x - d\n            print('Pour Some part D from X jug')\n    # pour some part from y jug        \n    elif(x==4):\n            if self.y>0:\n                self.y = self.y - d\n            \n            print('Pour Some part D from Y jug')\n    # empty jug x        \n    elif(x==5):\n            if self.x>0:\n                self.x=0\n            print('Empty jugX')\n    # empty jug y        \n    elif(x==6):\n            if self.y>0:\n                self.y=0\n            print('Empty jugY')\n    # pour water from y jug to fill x jug        \n    elif(x==7):\n            if self.x+self.y < self.capX+self.capY:\n                self.y= self.y-(self.capX-self.x)\n                self.x = self.capX\n            print('Pour from jugY to fill jugX')\n    #pour water from x jug to fill y jug\n    elif(x==8):\n            if self.x+self.y < self.capX+self.capY:\n                self.x=self.x-(self.capY-self.y)\n                self.y = self.capY\n            print('Pour from jugX to fill jugY')\n    # pour all water from y jug to x jug\n    elif(x==9):\n            if self.x+self.y < self.capX:\n                self.x= self.x+self.y\n                self.y=0\n            print('Pour all from jugY to jugX')\n    #pour all water from x jug to y jug\n    elif(x==10):\n            if self.x+self.y < self.capY:\n                self.x=0\n                self.y=self.x+self.y     \n                print('Pour all from jugX to jugY')\n\n    w.printVolume()\n    print('---')\n    self.appendPath()\n  ",water_jug_solution:"\n  w = WaterJug(5,3,4)\n  w.solve()\n  \n  OUTPUT:\n    With JugXCapacity 5 and JugYCapacity 3\n\n\n    [JugX=0, JugY=0]\n    Rule 2 Fill jugY completely\n    [JugX=0, JugY=3]\n    ---\n    [JugX=0, JugY=3]\n    Rule 9 Pour all from jugY to jugX\n    [JugX=3, JugY=0]\n    ---\n    [JugX=3, JugY=0]\n    Rule 2 Fill jugY completely\n    [JugX=3, JugY=3]\n    ---\n    [JugX=3, JugY=3]\n    Rule 7 Pour from jugY to fill jugX\n    [JugX=5, JugY=1]\n    ---\n    [JugX=5, JugY=1]\n    Rule 5 Empty jugX\n    [JugX=0, JugY=1]\n    ---\n    [JugX=0, JugY=1]\n    Rule 9 Pour all from jugY to jugX\n    [JugX=1, JugY=0]\n    ---\n    [JugX=1, JugY=0]\n    Rule 2 Fill jugY completely\n    [JugX=1, JugY=3]\n    ---\n    [JugX=1, JugY=3]\n    Rule 9 Pour all from jugY to jugX\n    [JugX=4, JugY=0]\n    ---\n    Total steps to solve : 8\n\n    [JugX:0, JugY:3]-> [JugX:3, JugY:0]-> [JugX:3, JugY:3]-> [JugX:5, JugY:1]->\n    [JugX:0, JugY:1]-> [JugX:1, JugY:0]-> [JugX:1, JugY:3]-> [JugX:4, JugY:0]\n    *****************************************************\n    With JugXCapacity 5 and JugYCapacity 3\n\n\n    [JugX=0, JugY=0]\n    Rule 2 Fill jugY completely\n    [JugX=0, JugY=5]\n    ---\n    [JugX=0, JugY=5]\n    Rule 7 Pour from jugY to fill jugX\n    [JugX=3, JugY=2]\n    ---\n    [JugX=3, JugY=2]\n    Rule 5 Empty jugX\n    [JugX=0, JugY=2]\n    ---\n    [JugX=0, JugY=2]\n    Rule 9 Pour all from jugY to jugX\n    [JugX=2, JugY=0]\n    ---\n    [JugX=2, JugY=0]\n    Rule 2 Fill jugY completely\n    [JugX=2, JugY=5]\n    ---\n    [JugX=2, JugY=5]\n    Rule 7 Pour from jugY to fill jugX\n    [JugX=3, JugY=4]\n    ---\n    Total steps to solve : 6\n\n    [JugX:0, JugY:5]->[JugX:3, JugY:2]->[JugX:0, JugY:2]\n    ->[JugX:2, JugY:0]->[JugX:2, JugY:5]->[JugX:3, JugY:4]\n\n  ",a_star_search_grid_generation:"\n  const generateGrid = (numbeOfRows, numberOfColumns, value) => {\n    return range(numbeOfRows).map((x) =>\n      range(numberOfColumns).map((y) => ({\n        ...value,\n        x,\n        y,\n      }))\n    );\n  };\n  ",a_star_search_coord_and_distance:"\n  const coordinatesToCheck = [\n    { y: 0, x: -1 },\n    { y: 1, x: -1 },\n    { y: 1, x: 0 },\n    { y: 1, x: 1 },\n    { y: 0, x: 1 },\n    { y: -1, x: 1 },\n    { y: -1, x: 0 },\n    { y: -1, x: -1 },\n  ];\n  \n  const getDistance = (a, b) => {\n    const colOffset = Math.abs(a.y - b.y);\n    const rowOffset = Math.abs(a.x - b.x);\n    const numberOfStraightSegments = Math.abs(colOffset - rowOffset);\n    const numberOfDiagonalSegments =\n      Math.max(colOffset, rowOffset) - numberOfStraightSegments;\n  \n    return numberOfStraightSegments * 10 + numberOfDiagonalSegments * 14; // 14 ~ 10 * sqrt(2)\n  };  \n  ",a_star_search_path_calculation:'  \n  export const computePath = (mainGrid, start, end) => {\n    const gridLength = mainGrid.length;\n\n    let counter = 0;\n    let openList = [];\n    const grid = generateGrid(gridLength, gridLength, {\n      fCost: 0,\n      gCost: 0,\n      hCost: 0,\n      parent: undefined,\n      isClosed: false,\n      isPath: false,\n      counter: 0,\n      x: 0,\n      y: 0,\n    });\n    openList.push(grid[start.x][start.y]);\n\n    while (openList.length > 0) {\n      const currentCell = minBy(openList, (c) => c.fCost);\n\n      if (!currentCell) {\n        // no path found\n        return grid;\n      }\n\n      if (currentCell.x === end.x && currentCell.y === end.y) {\n        let curr = currentCell;\n\n        while (curr.parent) {\n          grid[curr.x][curr.y].isPath = true;\n          curr = curr.parent;\n        }\n\n        return grid;\n      }\n\n      remove(openList, (c) => c.x === currentCell.x && c.y === currentCell.y);\n      currentCell.isClosed = true;\n      // eslint-disable-next-line no-loop-func\n      coordinatesToCheck.forEach((coordinatesToCheck) => {\n        const { x, y } = {\n          x: currentCell.x + coordinatesToCheck.x,\n          y: currentCell.y + coordinatesToCheck.y,\n        };\n\n        if (\n          x < 0 ||\n          x >= gridLength ||\n          y < 0 ||\n          y >= gridLength ||\n          (start.x === x && start.y === y) ||\n          grid[x][y].isClosed ||\n          mainGrid[x][y].status === "blocked"\n        ) {\n          return;\n        }\n\n        const neighbourCell = grid[x][y];\n\n        const gCost = currentCell.gCost + getDistance(currentCell, neighbourCell);\n        let gCostIsBest = false;\n\n        if (!openList.find((c) => c.x === x && c.y === y)) {\n          gCostIsBest = true;\n          neighbourCell.hCost = getDistance(neighbourCell, end);\n          openList.push(neighbourCell);\n        } else if (gCost < neighbourCell.gCost) {\n          gCostIsBest = true;\n        }\n\n        if (gCostIsBest) {\n          neighbourCell.parent = currentCell;\n          neighbourCell.gCost = gCost;\n          neighbourCell.fCost = neighbourCell.gCost + neighbourCell.hCost;\n          counter = counter + 1;\n          neighbourCell.counter = counter;\n        }\n      });\n    }\n    // No path found\n    return grid;\n  };\n  ',chatbot:'\n  import natural from "natural";\n\n  class Chatbot {  \n    constructor(name = "Agent") {\n      this.name = name;\n      this.questions = {};\n    }\n  \n    addQuestionsAnswer = (questions, answer) => {\n      let question;\n      for (question of questions) {\n        this.questions[question] = answer;\n      }\n    };\n  \n    //  stem words (fast but abstract words)\n    stemSentence = (sentence) => {\n      return natural.PorterStemmer.tokenizeAndStem(sentence);\n    };\n  \n    ask = (question) => {\n      question = question.toLowerCase().trim();\n      const questionWordList = this.stemSentence(question);\n      let index = 0;\n      let match = [];\n      //console.log(questionWordList);\n      let ques;\n      for (ques of Object.keys(this.questions)) {\n        ques = ques.toLowerCase().trim();\n        //console.log(ques);\n        const quesWordList = this.stemSentence(ques);\n        // console.log(quesWordList);\n        match.push(0);\n        let count = 0;\n        let word;\n        for (word of quesWordList) {\n          count += 1;\n          if (questionWordList.includes(word)) {\n            match[index] += 1;\n          }\n        }\n        match[index] = match[index] / Math.max(count, 1);\n        index += 1;\n        //  console.log(ques)\n        //  console.log(question)\n        // if (ques.toLowerCase().trim() === question) {\n        //   console.log(match);\n  \n        //   console.log(match.index(match.max));\n        //   return this.questions[ques];\n        // }\n      }\n      console.log(match);\n      const max = Math.max(...match);\n      console.log(max);\n      if (max >= 0.3) {\n        //  [match.index(max(match))]\n        const bestQuestionMatch = Object.keys(this.questions)[match.indexOf(max)];\n        return this.questions[bestQuestionMatch];\n      }\n      return "I did not understand the question!";\n    };\n  \n    listQuestions = () => {\n      var question;\n      let questionList = [];\n      for (question of Object.keys(this.questions)) {\n        // console.log(question);\n        questionList.push(question);\n      }\n      // console.log(questionList);\n      return questionList;\n    };\n  \n    initiateChat = () => {\n      // console.log("Chat with {this.name}");\n      // console.log("Availabe questions for {this.name}");\n      this.listQuestions();\n  \n      while (1) {\n        //var question = prompt("Enter question for {this.name} \n");\n        const question = "Hi";\n        if (\n          [\n            "quit",\n            "exit",\n            "close",\n            "stop",\n            "end",\n            ".",\n            "annihilate",\n            "disconnect",\n          ].includes(question)\n        ) {\n          break;\n        }\n        // console.log("{this.ask(question)}");\n      }\n    };\n  }   \n  ',chatbot_stem:"\n  //  stem words (fast but abstract words)\n  stemSentence = (sentence) => {\n    return natural.PorterStemmer.tokenizeAndStem(sentence);\n  };\n  ",chatbot_ask:'\n  ask = (question) => {\n    question = question.toLowerCase().trim();\n    const questionWordList = this.stemSentence(question);\n    let index = 0;\n    let match = [];\n    //console.log(questionWordList);\n    let ques;\n    for (ques of Object.keys(this.questions)) {\n      ques = ques.toLowerCase().trim();\n      //console.log(ques);\n      const quesWordList = this.stemSentence(ques);\n      // console.log(quesWordList);\n      match.push(0);\n      let count = 0;\n      let word;\n      for (word of quesWordList) {\n        count += 1;\n        if (questionWordList.includes(word)) {\n          match[index] += 1;\n        }\n      }\n      match[index] = match[index] / Math.max(count, 1);\n      index += 1;\n      //  console.log(ques)\n      //  console.log(question)\n      // if (ques.toLowerCase().trim() === question) {\n      //   console.log(match);\n\n      //   console.log(match.index(match.max));\n      //   return this.questions[ques];\n      // }\n    }\n    console.log(match);\n    const max = Math.max(...match);\n    console.log(max);\n    if (max >= 0.3) {\n      //  [match.index(max(match))]\n      const bestQuestionMatch = Object.keys(this.questions)[match.indexOf(max)];\n      return this.questions[bestQuestionMatch];\n    }\n    return "I did not understand the question!";\n  };\n  '}},747:function(e,n,t){"use strict";t.r(n);var a=t(0),l=t.n(a),s=t(189),r=t(201),o=t(202),i=t(591),u=t.n(i),c=t(82),f=t(593),g=t(73),p=t(720),m=t(721),h=t(733),d=t(63),y=t(722),x=t(74),b=t(719),j=t(195),J=Object(a.forwardRef)((function(e,n){var t=e.id,s=e.capacity,r=void 0===s?3:s,o=e.height,i=void 0===o?160:o,u=e.width,c=void 0===u?160:u,f=Object(a.useState)(0),p=Object(g.a)(f,2),m=p[0],h=p[1],d=Object(a.useState)(r),y=Object(g.a)(d,2),x=y[0],J=y[1],X=Object(a.useState)(0),Y=Object(g.a)(X,2),C=Y[0],w=Y[1],E=Object(a.useState)(!1),q=Object(g.a)(E,2),v=q[0],k=q[1],O=Object(a.useState)(0),L=Object(g.a)(O,2),S=L[0],P=L[1],_=Object(a.useState)(0),R=Object(g.a)(_,2),D=R[0],F=R[1];return Object(a.useImperativeHandle)(n,(function(){return{fill:function(e){console.log("Fill"),h(e)},drop:function(e){console.log("empty"),J(e)},toggleButton:function(e){w(e),k(!v)},empty:function(){k(!v),w(2),J(D)}}})),Object(a.useEffect)((function(){if(1===C){var e=S+m;if(e<=r){P(e);var n=(D+m)/r,a=D/r;F(e),b.a.fromTo(".water-fill"+t,.8,{attr:{x:-400}},{attr:{x:0},repeat:-1,ease:j.b.easeNone}),b.a.fromTo(".water-fill"+t,3,{attr:{y:378-378*a,height:440*a}},{attr:{y:378-378*n,height:440*n},ease:j.b.easeNone})}}else if(2===C){console.log("IN DROP id "+t),console.log(S,x);var l=S-x;if(l>=0){P(l);var s=D/r,o=(D-x)/r;F(l),b.a.fromTo(".water-fill"+t,.8,{attr:{x:-400}},{attr:{x:0},repeat:-1,ease:j.b.easeNone}),b.a.fromTo(".water-fill"+t,3,{attr:{y:378-378*s,height:440*s}},{attr:{y:378-378*o,height:440*o},ease:j.b.easeNone})}}}),[v]),l.a.createElement(l.a.Fragment,null,l.a.createElement("svg",{id:"Layer_1",height:i,width:c,"data-name":"Layer 1",xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 378 378"},l.a.createElement("defs",null,l.a.createElement("pattern",{id:"water",width:".25",height:"1.1",patternContentUnits:"objectBoundingBox"},l.a.createElement("path",{fill:"#4A90E2",d:"M0.25,1H0c0,0,0-0.659,0-0.916c0.083-0.303,0.158,0.334,0.25,0C0.25,0.327,0.25,1,0.25,1z"})),l.a.createElement("g",{id:"text"},l.a.createElement("circle",{cx:"50%",cy:"50%",r:"50%"})),l.a.createElement("mask",{id:"text-mask"},l.a.createElement("use",{x:"0",y:"0",href:"#text",opacity:"1",fill:"#ffffff"}))),l.a.createElement("use",{x:"0",y:"0",href:"#text",fill:"#222"}),l.a.createElement("rect",{className:"water-fill"+t,mask:"url(#text-mask)",fill:"url(#water)",x:"400",y:"0",width:"1600",height:"100%"}),l.a.createElement("text",{x:"25%",y:"50%",fill:"white",fontSize:"5em"},"".concat(S,"L/").concat(r,"L"))))})),X=l.a.memo(J),Y=t(91),C=t(90);new Y.a(7,5,1).pourRule();var w=function(){var e=Object(x.c)(C.g),n=Object(x.c)(C.h),t=Object(x.c)(C.k),r=Object(x.c)(C.i),o=Object(x.c)(C.j),i=Object(a.useRef)(null),b=Object(a.useRef)(null),j=Object(a.useState)(0),J=Object(g.a)(j,2),Y=J[0],w=J[1],E=Object(a.useState)(0),q=Object(g.a)(E,2),v=q[0],k=q[1],O=Object(a.useState)(0),L=Object(g.a)(O,2),S=L[0],P=L[1],_=Object(a.useState)(0),R=Object(g.a)(_,2),D=R[0],F=R[1],I=Object(a.useState)(0),T=Object(g.a)(I,2),B=T[0],W=T[1],M=Object(a.useState)(0),N=Object(g.a)(M,2),G=N[0],Q=N[1],A=Object(a.useState)(0),U=Object(g.a)(A,2),V=U[0],z=U[1],H=Object(x.b)();function K(e){return new Promise((function(n){return setTimeout(n,e)}))}var Z=function(){var e=Object(f.a)(u.a.mark((function e(){var n,t,a,l,s,f,g;return u.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:n=0,t=0,a=Object(c.a)(r),e.prev=3,a.s();case 5:if((l=a.n()).done){e.next=28;break}if(s=l.value,console.log(s),f=s[0],g=s[1],P(f),F(g),W(n),Q(t),console.log(f,g),console.log(n,t),f>n?(i.current.fill(f-n),i.current.toggleButton(1)):f<n&&(i.current.drop(n-f),i.current.toggleButton(2)),g>t?(b.current.fill(g-t),b.current.toggleButton(1)):g<t&&(b.current.drop(t-g),b.current.toggleButton(2)),n=f,t=g,!o){e.next=24;break}return e.abrupt("break",28);case 24:return e.next=26,K(4e3);case 26:e.next=5;break;case 28:e.next=33;break;case 30:e.prev=30,e.t0=e.catch(3),a.e(e.t0);case 33:return e.prev=33,a.f(),e.finish(33);case 36:case"end":return e.stop()}}),e,this,[[3,30,33,36]])})));return function(){return e.apply(this,arguments)}}();Object(a.useEffect)((function(){if(null!==i.current&&null!==b.current)if(0===r.length)console.log("empty"),i.current.empty(),b.current.empty();else try{Z()}catch(e){console.log(e)}}),[r]);var $=function(e,n){H(e(n))};return l.a.createElement(p.a,null,l.a.createElement(m.a,null,l.a.createElement(s.a,{container:!0,xl:12,spacing:4,justify:"center",alignItems:"center"},l.a.createElement(s.a,{item:!0,container:!0,xs:12,spacing:2,direction:"row",justify:"center",alignItems:"center"},l.a.createElement(p.a,null,l.a.createElement(m.a,null,l.a.createElement(s.a,{item:!0,container:!0,xs:12,spacing:2,direction:"row",justify:"center",alignItems:"center"},l.a.createElement(s.a,{xs:12,sm:6,item:!0,container:!0,direction:"column"},l.a.createElement(s.a,{item:!0},l.a.createElement(X,{id:1,height:"200",width:"200",ref:i,capacity:e})),l.a.createElement(s.a,{item:!0},l.a.createElement(h.a,{variant:"outlined",onClick:function(){i.current.fill(2),i.current.toggleButton(1)}},"Fill 2L")),l.a.createElement(s.a,{item:!0},l.a.createElement(h.a,{variant:"outlined",onClick:function(){i.current.drop(2),i.current.toggleButton(2)}},"Drop 2L"))),l.a.createElement(s.a,{xs:12,sm:6,item:!0,container:!0,direction:"column"},l.a.createElement(s.a,{item:!0},l.a.createElement(X,{id:2,height:"200",width:"200",ref:b,capacity:n})),l.a.createElement(s.a,{item:!0},l.a.createElement(h.a,{variant:"outlined",onClick:function(){b.current.fill(2),b.current.toggleButton(1)}},"Fill 2L")),l.a.createElement(s.a,{item:!0},l.a.createElement(h.a,{variant:"outlined",onClick:function(){b.current.drop(2),b.current.toggleButton(2)}},"Drop 2L"))))))),l.a.createElement(s.a,{item:!0,xs:12,container:!0,spacing:4,direction:"row",justify:"center",alignItems:"center"},l.a.createElement(s.a,{item:!0},l.a.createElement(d.a,null,"Jug Y Capacity : ",e)),l.a.createElement(s.a,{item:!0},l.a.createElement(d.a,null,"Jug X Capacity : ",n)),l.a.createElement(s.a,{item:!0},l.a.createElement(d.a,null,"Target : ",t)))," ",l.a.createElement(s.a,{item:!0,xs:12,container:!0,spacing:4,direction:"row",justify:"center",alignItems:"center"},l.a.createElement(s.a,{item:!0},l.a.createElement(y.a,{label:"Capacity For JUG X",plaardceholder:"X Litre",variant:"outlined","aria-label":"Capacity Fot jug X",value:Y,type:"number",onChange:function(e){return w(e.target.value)},onKeyPress:function(e){"Enter"===e.key&&$(C.a,{capacityX:parseInt(Y)})}})),l.a.createElement(s.a,{item:!0},l.a.createElement(y.a,{label:"Capacity For JUG Y",plaardceholder:"Y Litre",variant:"outlined","aria-label":"Capacity Fot jug Y",value:v,type:"number",onChange:function(e){return k(e.target.value)},onKeyPress:function(e){"Enter"===e.key&&$(C.b,{capacityY:parseInt(v)})}})),l.a.createElement(s.a,{item:!0},l.a.createElement(y.a,{label:"Target",plaardceholder:"X Litre",variant:"outlined","aria-label":"Target",value:V,type:"number",onChange:function(e){return z(e.target.value)},onKeyPress:function(e){"Enter"===e.key&&$(C.c,{target:parseInt(V)})}}))),l.a.createElement(s.a,{item:!0,container:!0,spacing:2,xs:12,direction:"row",justify:"center",alignItems:"center"},l.a.createElement(s.a,{item:!0},l.a.createElement(h.a,{variant:"contained",color:"secondary",onClick:function(){H(Object(C.f)()),i.current.empty(),b.current.empty(),H(Object(C.d)())}},"Compute Path")),l.a.createElement(s.a,{item:!0},l.a.createElement(h.a,{color:"primary",variant:"contained",onClick:function(){H(Object(C.f)())}},"Reset"))),l.a.createElement(s.a,{item:!0,container:!0,xs:12,direction:"row",justify:"center",alignItems:"center"},r.length>0?l.a.createElement(l.a.Fragment,null,l.a.createElement(s.a,{item:!0,xs:6},l.a.createElement(d.a,{align:"center"},"Current Transfer"),l.a.createElement(d.a,{align:"center"},"In JugX: ".concat(B," -> ").concat(S)),l.a.createElement(d.a,{align:"center"},"In JugY: ".concat(G," -> ").concat(D)))):null,l.a.createElement(s.a,{item:!0,container:!0,spacing:2,xs:6,direction:"column",justify:"center",alignItems:"center"},l.a.createElement(s.a,{item:!0},l.a.createElement(d.a,null,"Steps Involved")),r.length>0?r.map((function(e,n){return l.a.createElement(s.a,{item:!0,key:n},l.a.createElement(d.a,null,"JugX: ".concat(e[0],"L, JugY:").concat(e[1],"L")))})):null)))))};n.default=function(){var e=[o.a.water_jug_solution,o.a.water_jug_rules,o.a.water_jug_pour_rule,o.a.water_jug];return l.a.createElement(s.a,{item:!0,container:!0,direction:"column",spacing:2},l.a.createElement(s.a,{item:!0},l.a.createElement(w,null)),l.a.createElement(s.a,{item:!0,xs:12,sm:12},l.a.createElement(r.a,{tabNameList:["Solved Examples","Rules","Solution","Class"],tabCodeSnippetList:e,language:"javascript"})))}}}]);
//# sourceMappingURL=9.aac82669.chunk.js.map