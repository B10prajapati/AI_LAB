(this.webpackJsonpai_lab=this.webpackJsonpai_lab||[]).push([[7],{201:function(e,n,t){"use strict";var a=t(73),l=t(234),s=t(720),r=t(734),o=t(721),u=t(746),i=t(736),c=t(0),f=t.n(c),p=t(744),g=t(737);function m(e){var n=e.children,t=e.value,a=e.index,s=Object(l.a)(e,["children","value","index"]);return f.a.createElement("div",Object.assign({role:"tabpanel",hidden:t!==a,id:"simple-tabpanel-".concat(a),"aria-labelledby":"simple-tab-".concat(a)},s),t===a&&f.a.createElement(f.a.Fragment,null," ",n," "))}n.a=function(e){var n=f.a.useState(0),t=Object(a.a)(n,2),l=t[0],c=t[1],d=e.tabNameList,h=e.tabCodeSnippetList,y=e.language;return f.a.createElement(s.a,null,f.a.createElement(r.a,{title:"Code"}),f.a.createElement(o.a,null,f.a.createElement(u.a,{value:l,onChange:function(e,n){c(n)},"aria-label":"Tree Graph"},d.map((function(e,n){return f.a.createElement(i.a,Object.assign({key:n,label:e},function(e){return{id:"simple-tab-".concat(e),"aria-controls":"simple-tabpanel-".concat(e)}}(n)))}))),h.map((function(e,n){return f.a.createElement(m,{value:l,key:n,index:n},f.a.createElement(p.a,{language:y,style:g.a,lineProps:{style:{wordBreak:"break-all",whiteSpace:"pre-wrap"}},wrapLines:!0},e))}))))}},202:function(e,n,t){"use strict";t.d(n,"a",(function(){return a}));var a={dfs:"\n  DFS = (key, rev = false) => {\n    let dfs = [];\n    this.stack.push(key);\n    while (1) {\n      if (this.stack.length === 0) {\n        // array empty or does not exist\n        break;\n      }\n      const popped = this.stack.pop();\n\n      dfs.push(popped);\n      if (this.graph[popped] === undefined) {\n      } else {\n        let childData;\n        if (rev) childData = this.graph[popped].slice().reverse();\n        else childData = this.graph[popped];\n        for (let i of childData) {\n          this.stack.push(i);\n        }\n      }\n    }\n    return dfs;\n  };",bfs:"\n  BFS = (key) => {\n    this.queue.push(key);\n    let bfs = [];\n    while (1) {\n      if (this.queue.length === 0) {\n        // array empty or does not exist\n        break;\n      }\n      const popped = this.queue.shift();\n      bfs.push(popped);\n\n      if (this.graph[popped] === undefined) {\n      } else {\n        const childData = this.graph[popped];\n        for (let i of childData) {\n          this.queue.push(i);\n        }\n      }\n    }\n    return bfs;\n  };",graphClass:"\n  class Graph {\n    constructor() {\n      this.graph = [];\n      this.stack = [];\n      this.queue = [];\n    }\n    addEdge = (node, newNode) => {\n      if (this.graph[node] === undefined) this.graph[node] = [];\n      this.graph[node].push(newNode);\n    };\n  \n    DFS = (key, rev = false) => {\n      let dfs = [];\n      this.stack.push(key);\n      while (1) {\n        if (this.stack.length === 0) {\n          // array empty or does not exist\n          break;\n        }\n        const popped = this.stack.pop();\n  \n        dfs.push(popped);\n        if (this.graph[popped] === undefined) {\n        } else {\n          let childData;\n          if (rev) childData = this.graph[popped].slice().reverse();\n          else childData = this.graph[popped];\n          for (let i of childData) {\n            this.stack.push(i);\n          }\n        }\n      }\n      return dfs;\n    };\n    BFS = (key) => {\n      this.queue.push(key);\n      let bfs = [];\n      while (1) {\n        if (this.queue.length === 0) {\n          // array empty or does not exist\n          break;\n        }\n        const popped = this.queue.shift();\n        bfs.push(popped);\n  \n        if (this.graph[popped] === undefined) {\n        } else {\n          const childData = this.graph[popped];\n          for (let i of childData) {\n            this.queue.push(i);\n          }\n        }\n      }\n      return bfs;\n    };\n  }\n  ",water_jug:"\n  class WaterJug():\n    def __init__(self,x,y,target):\n        self.capX = x\n        self.capY = y\n        self.x = 0\n        self.y = 0\n        self.targe,end='\\n\\n\\n't = target\n        self.path = []\n        \n    def rule(self,x, d=0):\n        w.printVolume()\n        print('Rule {}'.format(x),end=' ')\n        # fill capX gallon jug completely\n        if(x==1):\n                if self.x<self.capX:\n                    self.x=self.capX\n                print('Fill jugX completely')\n        # fill capY gallon jug completely\n        elif (x==2):\n                if self.y<self.capY:\n                    self.y=self.capY\n                print('Fill jugY completely')\n        # pour some part from x jug\n        elif(x==3):\n                if self.x>0:\n                    self.x= self.x - d\n                print('Pour Some part D from X jug')\n        # pour some part from y jug        \n        elif(x==4):\n                if self.y>0:\n                    self.y = self.y - d\n                \n                print('Pour Some part D from Y jug')\n        # empty jug x        \n        elif(x==5):\n                if self.x>0:\n                    self.x=0\n                print('Empty jugX')\n        # empty jug y        \n        elif(x==6):\n                if self.y>0:\n                    self.y=0\n                print('Empty jugY')\n        # pour water from y jug to fill x jug        \n        elif(x==7):\n                if self.x+self.y < self.capX+self.capY:\n                    self.y= self.y-(self.capX-self.x)\n                    self.x = self.capX\n                print('Pour from jugY to fill jugX')\n        #pour water from x jug to fill y jug\n        elif(x==8):\n                if self.x+self.y < self.capX+self.capY:\n                    self.x=self.x-(self.capY-self.y)\n                    self.y = self.capY\n                print('Pour from jugX to fill jugY')\n        # pour all water from y jug to x jug\n        elif(x==9):\n                if self.x+self.y < self.capX:\n                    self.x= self.x+self.y\n                    self.y=0\n                print('Pour all from jugY to jugX')\n        #pour all water from x jug to y jug\n        elif(x==10):\n                if self.x+self.y < self.capY:\n                    self.x=0\n                    self.y=self.x+self.y     \n                    print('Pour all from jugX to jugY')\n\n        w.printVolume()\n        print('---')\n        self.appendPath()\n             \n    def printVolume(self):\n        print('[JugX={}, JugY={}]'.format(self.x, self.y))\n    \n    # print each state leading upto solution\n    def printPath(self):\n        for state in self.path:\n            if state==self.path[-1]:\n                print(f'[JugX:{state[0]}, JugY:{state[1]}]')\n                continue\n            print(f'[JugX:{state[0]}, JugY:{state[1]}]', end='->')\n    \n    # add new state generated to path\n    def appendPath(self):\n        self.path.append([self.x, self.y])\n    \n    def reset(self):\n        self.x=0\n        self.y=0\n        self.path=[]\n        \n    def pour(self): \n        self.reset()\n        yJug= self.capY\n        xJug=0\n#         self.rule(2)\n        step = 1\n        while ((yJug  is not self.target) and (xJug is not self.target)): \n            print('({},{})'.format(xJug, yJug))\n            \n\n            if(yJug < (self.capX-xJug)):\n                temp = yJug\n#                 self.rule(9)\n            else:\n                temp = (self.capX-xJug)\n#                 self.rule(7)\n            xJug = xJug + temp\n            yJug = yJug - temp\n\n#             temp = min(yJug, self.capX-xJug) \n#             xJug = xJug + temp \n#             yJug = yJug - temp \n\n            print('({},{})'.format(xJug, yJug))\n\n            step =  step + 1\n            if ((yJug == self.target) or (xJug == self.target)): \n                break\n\n            if yJug == 0: \n                yJug = self.capY\n#                 self.rule(2)\n                step =  step + 1\n\n            if xJug == self.capX: \n                xJug = 0\n#                 self.rule(5)\n                step =  step + 1\n    \n    # Solve using rules\n    def pourRule(self):\n        self.reset()\n        self.rule(2)\n        step = 1\n        while(1):\n            if(self.y==self.target or self.x==self.target):\n                break\n            \n            if(self.y < (self.capX-self.x)):\n                self.rule(9)\n            else:\n                self.rule(7)\n            \n            step=step+1\n            if(self.y==self.target or self.x==self.target):\n                break\n            \n            if self.y==0:\n                self.rule(2)\n                step = step + 1\n            \n            if self.x==self.capX:\n                self.rule(5)\n                step = step+1\n        return step \n\n    # Reverse the capacity of jugs\n    def reverseJugCapacity(self):\n        self.capX, self.capY = self.capY, self.capX\n    \n    # Solve  for both x,y and y,x conditions \n    def solve(self):\n        print(f'With JugXCapacity {self.capX} and JugYCapacity {self.capY}',end='\\n\\n\\n')\n        print(f'Total steps to solve : {self.pourRule()}',end='\\n\\n')\n        self.printPath()\n        print('*'*100)\n        print(f'With JugXCapacity {self.capX} and JugYCapacity {self.capY}',end='\\n\\n\\n')\n        self.reverseJugCapacity()\n        print(f'Total steps to solve : {self.pourRule()}',end='\\n\\n')\n        self.printPath()\n  ",water_jug_pour_rule:"\n  # Solve using rules\n  def pourRule(self):\n      self.reset()\n      self.rule(2)\n      step = 1\n      while(1):\n          if(self.y==self.target or self.x==self.target):\n              break\n          \n          if(self.y < (self.capX-self.x)):\n              self.rule(9)\n          else:\n              self.rule(7)\n          \n          step=step+1\n          if(self.y==self.target or self.x==self.target):\n              break\n          \n          if self.y==0:\n              self.rule(2)\n              step = step + 1\n          \n          if self.x==self.capX:\n              self.rule(5)\n              step = step+1\n      return step \n  ",water_jug_rules:"\n  def rule(self,x, d=0):\n    w.printVolume()\n    print('Rule {}'.format(x),end=' ')\n    # fill capX gallon jug completely\n    if(x==1):\n            if self.x<self.capX:\n                self.x=self.capX\n            print('Fill jugX completely')\n    # fill capY gallon jug completely\n    elif (x==2):\n            if self.y<self.capY:\n                self.y=self.capY\n            print('Fill jugY completely')\n    # pour some part from x jug\n    elif(x==3):\n            if self.x>0:\n                self.x= self.x - d\n            print('Pour Some part D from X jug')\n    # pour some part from y jug        \n    elif(x==4):\n            if self.y>0:\n                self.y = self.y - d\n            \n            print('Pour Some part D from Y jug')\n    # empty jug x        \n    elif(x==5):\n            if self.x>0:\n                self.x=0\n            print('Empty jugX')\n    # empty jug y        \n    elif(x==6):\n            if self.y>0:\n                self.y=0\n            print('Empty jugY')\n    # pour water from y jug to fill x jug        \n    elif(x==7):\n            if self.x+self.y < self.capX+self.capY:\n                self.y= self.y-(self.capX-self.x)\n                self.x = self.capX\n            print('Pour from jugY to fill jugX')\n    #pour water from x jug to fill y jug\n    elif(x==8):\n            if self.x+self.y < self.capX+self.capY:\n                self.x=self.x-(self.capY-self.y)\n                self.y = self.capY\n            print('Pour from jugX to fill jugY')\n    # pour all water from y jug to x jug\n    elif(x==9):\n            if self.x+self.y < self.capX:\n                self.x= self.x+self.y\n                self.y=0\n            print('Pour all from jugY to jugX')\n    #pour all water from x jug to y jug\n    elif(x==10):\n            if self.x+self.y < self.capY:\n                self.x=0\n                self.y=self.x+self.y     \n                print('Pour all from jugX to jugY')\n\n    w.printVolume()\n    print('---')\n    self.appendPath()\n  ",water_jug_solution:"\n  w = WaterJug(5,3,4)\n  w.solve()\n  \n  OUTPUT:\n    With JugXCapacity 5 and JugYCapacity 3\n\n\n    [JugX=0, JugY=0]\n    Rule 2 Fill jugY completely\n    [JugX=0, JugY=3]\n    ---\n    [JugX=0, JugY=3]\n    Rule 9 Pour all from jugY to jugX\n    [JugX=3, JugY=0]\n    ---\n    [JugX=3, JugY=0]\n    Rule 2 Fill jugY completely\n    [JugX=3, JugY=3]\n    ---\n    [JugX=3, JugY=3]\n    Rule 7 Pour from jugY to fill jugX\n    [JugX=5, JugY=1]\n    ---\n    [JugX=5, JugY=1]\n    Rule 5 Empty jugX\n    [JugX=0, JugY=1]\n    ---\n    [JugX=0, JugY=1]\n    Rule 9 Pour all from jugY to jugX\n    [JugX=1, JugY=0]\n    ---\n    [JugX=1, JugY=0]\n    Rule 2 Fill jugY completely\n    [JugX=1, JugY=3]\n    ---\n    [JugX=1, JugY=3]\n    Rule 9 Pour all from jugY to jugX\n    [JugX=4, JugY=0]\n    ---\n    Total steps to solve : 8\n\n    [JugX:0, JugY:3]-> [JugX:3, JugY:0]-> [JugX:3, JugY:3]-> [JugX:5, JugY:1]->\n    [JugX:0, JugY:1]-> [JugX:1, JugY:0]-> [JugX:1, JugY:3]-> [JugX:4, JugY:0]\n    *****************************************************\n    With JugXCapacity 5 and JugYCapacity 3\n\n\n    [JugX=0, JugY=0]\n    Rule 2 Fill jugY completely\n    [JugX=0, JugY=5]\n    ---\n    [JugX=0, JugY=5]\n    Rule 7 Pour from jugY to fill jugX\n    [JugX=3, JugY=2]\n    ---\n    [JugX=3, JugY=2]\n    Rule 5 Empty jugX\n    [JugX=0, JugY=2]\n    ---\n    [JugX=0, JugY=2]\n    Rule 9 Pour all from jugY to jugX\n    [JugX=2, JugY=0]\n    ---\n    [JugX=2, JugY=0]\n    Rule 2 Fill jugY completely\n    [JugX=2, JugY=5]\n    ---\n    [JugX=2, JugY=5]\n    Rule 7 Pour from jugY to fill jugX\n    [JugX=3, JugY=4]\n    ---\n    Total steps to solve : 6\n\n    [JugX:0, JugY:5]->[JugX:3, JugY:2]->[JugX:0, JugY:2]\n    ->[JugX:2, JugY:0]->[JugX:2, JugY:5]->[JugX:3, JugY:4]\n\n  ",a_star_search_grid_generation:"\n  const generateGrid = (numbeOfRows, numberOfColumns, value) => {\n    return range(numbeOfRows).map((x) =>\n      range(numberOfColumns).map((y) => ({\n        ...value,\n        x,\n        y,\n      }))\n    );\n  };\n  ",a_star_search_coord_and_distance:"\n  const coordinatesToCheck = [\n    { y: 0, x: -1 },\n    { y: 1, x: -1 },\n    { y: 1, x: 0 },\n    { y: 1, x: 1 },\n    { y: 0, x: 1 },\n    { y: -1, x: 1 },\n    { y: -1, x: 0 },\n    { y: -1, x: -1 },\n  ];\n  \n  const getDistance = (a, b) => {\n    const colOffset = Math.abs(a.y - b.y);\n    const rowOffset = Math.abs(a.x - b.x);\n    const numberOfStraightSegments = Math.abs(colOffset - rowOffset);\n    const numberOfDiagonalSegments =\n      Math.max(colOffset, rowOffset) - numberOfStraightSegments;\n  \n    return numberOfStraightSegments * 10 + numberOfDiagonalSegments * 14; // 14 ~ 10 * sqrt(2)\n  };  \n  ",a_star_search_path_calculation:'  \n  export const computePath = (mainGrid, start, end) => {\n    const gridLength = mainGrid.length;\n\n    let counter = 0;\n    let openList = [];\n    const grid = generateGrid(gridLength, gridLength, {\n      fCost: 0,\n      gCost: 0,\n      hCost: 0,\n      parent: undefined,\n      isClosed: false,\n      isPath: false,\n      counter: 0,\n      x: 0,\n      y: 0,\n    });\n    openList.push(grid[start.x][start.y]);\n\n    while (openList.length > 0) {\n      const currentCell = minBy(openList, (c) => c.fCost);\n\n      if (!currentCell) {\n        // no path found\n        return grid;\n      }\n\n      if (currentCell.x === end.x && currentCell.y === end.y) {\n        let curr = currentCell;\n\n        while (curr.parent) {\n          grid[curr.x][curr.y].isPath = true;\n          curr = curr.parent;\n        }\n\n        return grid;\n      }\n\n      remove(openList, (c) => c.x === currentCell.x && c.y === currentCell.y);\n      currentCell.isClosed = true;\n      // eslint-disable-next-line no-loop-func\n      coordinatesToCheck.forEach((coordinatesToCheck) => {\n        const { x, y } = {\n          x: currentCell.x + coordinatesToCheck.x,\n          y: currentCell.y + coordinatesToCheck.y,\n        };\n\n        if (\n          x < 0 ||\n          x >= gridLength ||\n          y < 0 ||\n          y >= gridLength ||\n          (start.x === x && start.y === y) ||\n          grid[x][y].isClosed ||\n          mainGrid[x][y].status === "blocked"\n        ) {\n          return;\n        }\n\n        const neighbourCell = grid[x][y];\n\n        const gCost = currentCell.gCost + getDistance(currentCell, neighbourCell);\n        let gCostIsBest = false;\n\n        if (!openList.find((c) => c.x === x && c.y === y)) {\n          gCostIsBest = true;\n          neighbourCell.hCost = getDistance(neighbourCell, end);\n          openList.push(neighbourCell);\n        } else if (gCost < neighbourCell.gCost) {\n          gCostIsBest = true;\n        }\n\n        if (gCostIsBest) {\n          neighbourCell.parent = currentCell;\n          neighbourCell.gCost = gCost;\n          neighbourCell.fCost = neighbourCell.gCost + neighbourCell.hCost;\n          counter = counter + 1;\n          neighbourCell.counter = counter;\n        }\n      });\n    }\n    // No path found\n    return grid;\n  };\n  ',chatbot:'\n  import natural from "natural";\n\n  class Chatbot {  \n    constructor(name = "Agent") {\n      this.name = name;\n      this.questions = {};\n    }\n  \n    addQuestionsAnswer = (questions, answer) => {\n      let question;\n      for (question of questions) {\n        this.questions[question] = answer;\n      }\n    };\n  \n    //  stem words (fast but abstract words)\n    stemSentence = (sentence) => {\n      return natural.PorterStemmer.tokenizeAndStem(sentence);\n    };\n  \n    ask = (question) => {\n      question = question.toLowerCase().trim();\n      const questionWordList = this.stemSentence(question);\n      let index = 0;\n      let match = [];\n      //console.log(questionWordList);\n      let ques;\n      for (ques of Object.keys(this.questions)) {\n        ques = ques.toLowerCase().trim();\n        //console.log(ques);\n        const quesWordList = this.stemSentence(ques);\n        // console.log(quesWordList);\n        match.push(0);\n        let count = 0;\n        let word;\n        for (word of quesWordList) {\n          count += 1;\n          if (questionWordList.includes(word)) {\n            match[index] += 1;\n          }\n        }\n        match[index] = match[index] / Math.max(count, 1);\n        index += 1;\n        //  console.log(ques)\n        //  console.log(question)\n        // if (ques.toLowerCase().trim() === question) {\n        //   console.log(match);\n  \n        //   console.log(match.index(match.max));\n        //   return this.questions[ques];\n        // }\n      }\n      console.log(match);\n      const max = Math.max(...match);\n      console.log(max);\n      if (max >= 0.3) {\n        //  [match.index(max(match))]\n        const bestQuestionMatch = Object.keys(this.questions)[match.indexOf(max)];\n        return this.questions[bestQuestionMatch];\n      }\n      return "I did not understand the question!";\n    };\n  \n    listQuestions = () => {\n      var question;\n      let questionList = [];\n      for (question of Object.keys(this.questions)) {\n        // console.log(question);\n        questionList.push(question);\n      }\n      // console.log(questionList);\n      return questionList;\n    };\n  \n    initiateChat = () => {\n      // console.log("Chat with {this.name}");\n      // console.log("Availabe questions for {this.name}");\n      this.listQuestions();\n  \n      while (1) {\n        //var question = prompt("Enter question for {this.name} \n");\n        const question = "Hi";\n        if (\n          [\n            "quit",\n            "exit",\n            "close",\n            "stop",\n            "end",\n            ".",\n            "annihilate",\n            "disconnect",\n          ].includes(question)\n        ) {\n          break;\n        }\n        // console.log("{this.ask(question)}");\n      }\n    };\n  }   \n  ',chatbot_stem:"\n  //  stem words (fast but abstract words)\n  stemSentence = (sentence) => {\n    return natural.PorterStemmer.tokenizeAndStem(sentence);\n  };\n  ",chatbot_ask:'\n  ask = (question) => {\n    question = question.toLowerCase().trim();\n    const questionWordList = this.stemSentence(question);\n    let index = 0;\n    let match = [];\n    //console.log(questionWordList);\n    let ques;\n    for (ques of Object.keys(this.questions)) {\n      ques = ques.toLowerCase().trim();\n      //console.log(ques);\n      const quesWordList = this.stemSentence(ques);\n      // console.log(quesWordList);\n      match.push(0);\n      let count = 0;\n      let word;\n      for (word of quesWordList) {\n        count += 1;\n        if (questionWordList.includes(word)) {\n          match[index] += 1;\n        }\n      }\n      match[index] = match[index] / Math.max(count, 1);\n      index += 1;\n      //  console.log(ques)\n      //  console.log(question)\n      // if (ques.toLowerCase().trim() === question) {\n      //   console.log(match);\n\n      //   console.log(match.index(match.max));\n      //   return this.questions[ques];\n      // }\n    }\n    console.log(match);\n    const max = Math.max(...match);\n    console.log(max);\n    if (max >= 0.3) {\n      //  [match.index(max(match))]\n      const bestQuestionMatch = Object.keys(this.questions)[match.indexOf(max)];\n      return this.questions[bestQuestionMatch];\n    }\n    return "I did not understand the question!";\n  };\n  '}},344:function(e,n,t){e.exports={gridTable:"Grid_gridTable__1LghC",gridCell:"Grid_gridCell__3p4DB",gridTooltip:"Grid_gridTooltip___eKIf",blocked:"Grid_blocked__JkDxv",checked:"Grid_checked__27eM_",start:"Grid_start__myL7-",end:"Grid_end__XB9oW",fadeInChecked:"Grid_fadeInChecked__9eRlO",closed:"Grid_closed__lDSnE",fadeInClosed:"Grid_fadeInClosed__2m-0b",path:"Grid_path__14bdQ",fadeInPath:"Grid_fadeInPath__iQwuY",tooltipRoot:"Grid_tooltipRoot__1JPCq"}},743:function(e,n,t){"use strict";t.r(n);var a=t(0),l=t.n(a),s=t(189),r=t(720),o=t(721),u=t(73),i=t(158),c=t(733),f=t(114),p=t(182),g=t(63),m=t(175),d=t(170),h=t(590),y=t(181),x=t(74),b=t(84);function J(){return Math.round(20*Math.random())-10}function E(){var e=50+J(),n=50+J();return{top:"".concat(e,"%"),left:"".concat(n,"%"),transform:"translate(-".concat(e,"%, -").concat(n,"%)")}}var j=Object(i.a)((function(e){return{paper:{position:"absolute",width:400,backgroundColor:e.palette.background.paper,border:"2px solid #000",boxShadow:e.shadows[5],padding:e.spacing(2,4,3)}}})),C=function(){var e=Object(a.useState)(!1),n=Object(u.a)(e,2),t=n[0],r=n[1],o=j(),i=l.a.useState(E),J=Object(u.a)(i,1)[0],C=Object(x.c)(b.i),X=Object(x.b)();return l.a.createElement(l.a.Fragment,null,l.a.createElement(c.a,{startIcon:l.a.createElement(y.a,null),onClick:function(){return r(!0)},style:{outline:0},variant:"contained",color:"secondary"},"Info"),l.a.createElement(f.a,{open:t,onClose:function(){return r(!1)},"aria-labelledby":"A Star Pathfinding React Demo"},l.a.createElement(p.a,{style:J,className:o.paper},l.a.createElement(s.a,{container:!0,spacing:4,justify:"center",alignItems:"center"},l.a.createElement(s.a,{item:!0},l.a.createElement(g.a,{variant:"h5"},"How does it work ?")),l.a.createElement(s.a,{item:!0},l.a.createElement(m.a,null,l.a.createElement(d.a,null,l.a.createElement(g.a,null,"Press start to compute the path")),l.a.createElement(d.a,null,l.a.createElement(g.a,null,"Hover over the cells to see more details about the result")),l.a.createElement(d.a,null,l.a.createElement(g.a,null,"Use the set start/end and draw button to change the obstacles")))),l.a.createElement(s.a,{item:!0},l.a.createElement(g.a,{variant:"h5"},"Change Pattern")),l.a.createElement(s.a,{item:!0,container:!0,spacing:2},[{preset:"a-star-text",text:"A-Star Text"},{preset:"labyrinth",text:"Labyrinth"},{preset:"random",text:"Random"},{preset:"blank",text:"Blank Canvas"}].map((function(e){return l.a.createElement(s.a,{item:!0,key:e.preset},l.a.createElement(c.a,{variant:"contained",disabled:C===e.preset,onClick:function(){return X(Object(b.b)({preset:e.preset}))},style:{outline:0}},e.text))}))),l.a.createElement(s.a,{item:!0},l.a.createElement(g.a,{variant:"h5"},"Ressources I found useful")),l.a.createElement(s.a,{item:!0},l.a.createElement(m.a,null,l.a.createElement(d.a,{button:!0},l.a.createElement(h.a,{color:"secondary",variant:"body2",href:"https://www.youtube.com/watch?v=-L-WgKMFuhE"},"Sebastian Lague's Youtube Video")),l.a.createElement(d.a,{button:!0},l.a.createElement(h.a,{color:"secondary",variant:"body2",href:"https://briangrinstead.com/blog/astar-search-algorithm-in-javascript-updated/"},"Brian Grinstead's blog article on A* implementation and optimization.")),l.a.createElement(d.a,{button:!0},l.a.createElement(h.a,{color:"secondary",variant:"body2",href:"http://www.codeblocq.com/2020/01/A-Star-Pathfinding-React-Demo/"},"Jonathan Klughertz's blog on implementation of a* in react. Design and code concept from the blog demo."))))))))},X=t(738),Y=t(739),q=t(740),w=t(20),_=function(){var e=Object(x.c)(b.g),n=Object(x.b)();return l.a.createElement(s.a,{container:!0,spacing:2},l.a.createElement(s.a,{item:!0},l.a.createElement(c.a,{variant:"contained",color:"primary",startIcon:l.a.createElement(X.a,null),disabled:e===w.b.setStart,onClick:function(){return n(Object(b.m)({mode:e===w.b.setStart?w.b.draw:w.b.setStart}))},style:{outline:0}},"SET START")),l.a.createElement(s.a,{item:!0},l.a.createElement(c.a,{color:"primary",variant:"contained",startIcon:l.a.createElement(X.a,null),disabled:e===w.b.setEnd,onClick:function(){return n(Object(b.m)({mode:e===w.b.setEnd?w.b.draw:w.b.setEnd}))},style:{outline:0}},"SET END")),l.a.createElement(s.a,{item:!0},l.a.createElement(c.a,{color:"primary",variant:"contained",startIcon:l.a.createElement(X.a,null),disabled:e===w.b.draw,onClick:function(){return n(Object(b.m)({mode:w.b.draw}))},style:{outline:0}},"DRAW")),l.a.createElement(s.a,{item:!0},l.a.createElement(c.a,{color:"primary",variant:"contained",startIcon:l.a.createElement(Y.a,null),onClick:function(){return n(Object(b.a)())},style:{outline:0}},"START")),l.a.createElement(s.a,{item:!0},l.a.createElement(c.a,{color:"primary",variant:"contained",startIcon:l.a.createElement(q.a,null),onClick:function(){return n(Object(b.c)())},style:{outline:0}},"RESET")),l.a.createElement(s.a,{item:!0},l.a.createElement(C,null)))},v=t(32),k=t(742),O=t(109),S=O.Table,L=O.TableBody,P=O.TableRow,R=O.TableCell,D=O.Typography,T=O.TableContainer,I=O.Paper,G=function(e){var n=e.cell;return l.a.createElement(l.a.Fragment,null,l.a.createElement(T,{component:I},l.a.createElement(S,null,l.a.createElement(L,null,l.a.createElement(P,null,l.a.createElement(R,null,l.a.createElement(D,null,function(e){return e.isPath?"Optimal Path":e.isClosed?"Considered for the optimal path":"Computed but never considered"}(n)))),l.a.createElement(P,null,l.a.createElement(R,null,l.a.createElement(D,null,"Distance from Start")),l.a.createElement(R,null,l.a.createElement(D,null,n.gCost))),l.a.createElement(P,null,l.a.createElement(R,null,l.a.createElement(D,null,"Distance from End")),l.a.createElement(R,null,l.a.createElement(D,null,n.hCost))),l.a.createElement(P,null,l.a.createElement(R,null,l.a.createElement(D,null,"Sum of the Two")),l.a.createElement(R,null,l.a.createElement(D,null,n.fCost))),l.a.createElement(P,null,l.a.createElement(R,null,l.a.createElement(D,null,"Steps to reach")),l.a.createElement(R,null,l.a.createElement(D,null,n.counter)))))))},W=t(595),F=t.n(W),M=t(344),B=t.n(M),A=l.a.memo((function(e){var n,t,a,s,r=e.cell,o=e.rowIndex,u=e.colIndex,i=e.start,c=e.end,f=e.path,p=e.onCellClick,g=f&&(null===(n=f[o][u])||void 0===n?void 0:n.isClosed),m=f&&(null===(t=f[o][u])||void 0===t?void 0:t.isPath),d=f&&0!==(null===(a=f[o][u])||void 0===a?void 0:a.fCost),h=f?null===(s=f[o][u])||void 0===s?void 0:s.counter:0;return l.a.createElement(l.a.Fragment,null,l.a.createElement("td",{className:F()(B.a.gridCell,B.a[r.status],Object(v.a)({},B.a.start,o===i.x&&u===i.y),Object(v.a)({},B.a.end,o===c.x&&u===c.y),Object(v.a)({},B.a.closed,g),Object(v.a)({},B.a.checked,d),Object(v.a)({},B.a.path,m)),key:"".concat(o,"-").concat(u),onClick:p(o,u),style:{animationDelay:h?"".concat(10*h,"ms"):void 0}},f&&(g||d||m)?l.a.createElement(k.a,{title:l.a.createElement(G,{cell:f[o][u]})},l.a.createElement("div",{className:B.a.gridTooltip,style:{color:"transparent"}})):null))})),N=function(e){var n=Object(x.c)(b.f),t=Object(x.c)(b.e),s=Object(x.c)(b.h),r=Object(x.c)(b.j),o=Object(x.c)(b.g),i=Object(x.b)(),c=Object(a.useState)(!1),f=Object(u.a)(c,2),p=f[0],g=f[1],m=function(){return g(!0)},d=function(){return g(!1)};Object(a.useEffect)((function(){return document.addEventListener("mousedown",m),document.addEventListener("mouseup",d),function(){document.removeEventListener("mousedown",m),document.removeEventListener("mouseUp",d)}}),[]);var h=function(e,n){return function(){console.log(e,n),o===w.b.draw?i(Object(b.k)({x:e,y:n})):o===w.b.setStart?i(Object(b.n)({x:e,y:n})):o===w.b.setEnd&&i(Object(b.l)({x:e,y:n}))}};return l.a.createElement("div",{className:B.a.gridRoot},l.a.createElement("table",{className:B.a.gridTable},l.a.createElement("tbody",null,n.map((function(e,n){return l.a.createElement("tr",{key:n,style:{border:"1px solid black"}},e.map((function(e,a){return l.a.createElement(A,{key:"".concat(n," - ").concat(a),cell:e,rowIndex:n,colIndex:a,start:r,end:t,path:s,isPressed:p,onCellClick:h})})))})))))},Q=function(){return l.a.createElement(r.a,null,l.a.createElement(o.a,null,l.a.createElement(s.a,{container:!0,spacing:2,justify:"center",alignItems:"center"},l.a.createElement(s.a,{item:!0},l.a.createElement(_,null)),l.a.createElement(s.a,{item:!0},l.a.createElement(N,null)))))},V=t(201),z=t(202);n.default=function(){var e=[z.a.a_star_search_grid_generation,z.a.a_star_search_coord_and_distance,z.a.a_star_search_path_calculation];return l.a.createElement(s.a,{item:!0,container:!0,direction:"column",spacing:2},l.a.createElement(s.a,{item:!0},l.a.createElement(Q,null)),l.a.createElement(s.a,{item:!0,xs:12,sm:12},l.a.createElement(V.a,{tabNameList:["Grid Generation","Cost","Path Calculation"],tabCodeSnippetList:e,language:"javascript"})))}}}]);
//# sourceMappingURL=7.238f9888.chunk.js.map