{"version":3,"sources":["components/CodeBlock.jsx","snippets/index.js","features/waterjug/Waterjug.jsx","features/waterjug/WaterjugComponent.js","pages/lab3/lab3.js"],"names":["TabPanel","props","children","value","index","other","role","hidden","id","aria-labelledby","CodeBlock","React","useState","setValue","tabNameList","tabCodeSnippetList","language","title","onChange","event","newValue","aria-label","map","name","key","label","a11yProps","codeSnippet","style","dracula","lineProps","wordBreak","whiteSpace","wrapLines","snippets","dfs","bfs","graphClass","water_jug","water_jug_pour_rule","water_jug_rules","water_jug_solution","a_star_search_grid_generation","a_star_search_coord_and_distance","a_star_search_path_calculation","chatbot","chatbot_stem","chatbot_ask","WaterjugComponent","forwardRef","ref","capacity","height","width","waterVolume","setWaterVolume","emptyWaterVolume","setEmptyWaterVolume","toggle","setToggle","toggleRender","setToggleRender","waterLevel","setWaterLevel","temporaryLevel","setTemporaryLevel","useImperativeHandle","fill","x","console","log","drop","toggleButton","empty","useEffect","rise","waterRatio","previousRatio","TweenMax","fromTo","attr","repeat","ease","Linear","easeNone","y","emptyWaterRatio","data-name","xmlns","viewBox","patternContentUnits","d","cx","cy","r","href","opacity","className","mask","fontSize","memo","WaterJugClass","pourRule","capX","useSelector","selectCapacityX","capY","selectCapacityY","targt","selectTarget","path","selectPath","stop","selectStopAnimation","refX","useRef","refY","capacityX","setCapacityX","capacityY","setCapacityY","jugX","setJugX","jugY","setJugY","prevJugX","setPrevJugX","prevJugY","setPrevJugY","target","setTarget","dispatch","useDispatch","sleep","ms","Promise","resolve","setTimeout","waitLoop","a","tempX","tempY","i","current","length","e","handleSubmit","functionArguement","parameters","Card","CardContent","Grid","container","xl","spacing","justify","alignItems","item","xs","direction","sm","Waterjug","Button","variant","onClick","Typography","TextField","plaardceholder","type","onKeyPress","addCapacityX","parseInt","addCapacityY","addTarget","color","reset","computePath","align","Lab3"],"mappings":"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","file":"static/js/9.aac82669.chunk.js","sourcesContent":["import { Card, CardContent, CardHeader, Tab, Tabs } from \"@material-ui/core\";\nimport React from \"react\";\nimport SyntaxHighlighter from \"react-syntax-highlighter\";\n\nimport { dracula } from \"react-syntax-highlighter/dist/esm/styles/hljs\";\nimport { PropTypes } from \"prop-types\";\nfunction TabPanel(props) {\n  const { children, value, index, ...other } = props;\n\n  return (\n    <div\n      role=\"tabpanel\"\n      hidden={value !== index}\n      id={`simple-tabpanel-${index}`}\n      aria-labelledby={`simple-tab-${index}`}\n      {...other}\n    >\n      {value === index && <> {children} </>}\n    </div>\n  );\n}\n\nTabPanel.propTypes = {\n  children: PropTypes.node,\n  index: PropTypes.any.isRequired,\n  value: PropTypes.any.isRequired,\n};\nfunction a11yProps(index) {\n  return {\n    id: `simple-tab-${index}`,\n    \"aria-controls\": `simple-tabpanel-${index}`,\n  };\n}\nconst CodeBlock = (props) => {\n  const [value, setValue] = React.useState(0);\n\n  const handleChange = (event, newValue) => {\n    setValue(newValue);\n  };\n\n  const { tabNameList, tabCodeSnippetList, language } = props;\n  return (\n    <Card>\n      <CardHeader title=\"Code\" />\n      <CardContent>\n        <Tabs value={value} onChange={handleChange} aria-label=\"Tree Graph\">\n          {tabNameList.map((name, index) => {\n            return <Tab key={index} label={name} {...a11yProps(index)} />;\n          })}\n        </Tabs>\n        {tabCodeSnippetList.map((codeSnippet, index) => {\n          return (\n            <TabPanel value={value} key={index} index={index}>\n              <SyntaxHighlighter\n                language={language}\n                style={dracula}\n                lineProps={{\n                  style: { wordBreak: \"break-all\", whiteSpace: \"pre-wrap\" },\n                }}\n                wrapLines={true}\n              >\n                {codeSnippet}\n              </SyntaxHighlighter>\n            </TabPanel>\n          );\n        })}\n      </CardContent>\n    </Card>\n  );\n};\n\nexport default CodeBlock;\n","export const snippets = {\n  dfs: `\n  DFS = (key, rev = false) => {\n    let dfs = [];\n    this.stack.push(key);\n    while (1) {\n      if (this.stack.length === 0) {\n        // array empty or does not exist\n        break;\n      }\n      const popped = this.stack.pop();\n\n      dfs.push(popped);\n      if (this.graph[popped] === undefined) {\n      } else {\n        let childData;\n        if (rev) childData = this.graph[popped].slice().reverse();\n        else childData = this.graph[popped];\n        for (let i of childData) {\n          this.stack.push(i);\n        }\n      }\n    }\n    return dfs;\n  };`,\n  bfs: `\n  BFS = (key) => {\n    this.queue.push(key);\n    let bfs = [];\n    while (1) {\n      if (this.queue.length === 0) {\n        // array empty or does not exist\n        break;\n      }\n      const popped = this.queue.shift();\n      bfs.push(popped);\n\n      if (this.graph[popped] === undefined) {\n      } else {\n        const childData = this.graph[popped];\n        for (let i of childData) {\n          this.queue.push(i);\n        }\n      }\n    }\n    return bfs;\n  };`,\n  graphClass: `\n  class Graph {\n    constructor() {\n      this.graph = [];\n      this.stack = [];\n      this.queue = [];\n    }\n    addEdge = (node, newNode) => {\n      if (this.graph[node] === undefined) this.graph[node] = [];\n      this.graph[node].push(newNode);\n    };\n  \n    DFS = (key, rev = false) => {\n      let dfs = [];\n      this.stack.push(key);\n      while (1) {\n        if (this.stack.length === 0) {\n          // array empty or does not exist\n          break;\n        }\n        const popped = this.stack.pop();\n  \n        dfs.push(popped);\n        if (this.graph[popped] === undefined) {\n        } else {\n          let childData;\n          if (rev) childData = this.graph[popped].slice().reverse();\n          else childData = this.graph[popped];\n          for (let i of childData) {\n            this.stack.push(i);\n          }\n        }\n      }\n      return dfs;\n    };\n    BFS = (key) => {\n      this.queue.push(key);\n      let bfs = [];\n      while (1) {\n        if (this.queue.length === 0) {\n          // array empty or does not exist\n          break;\n        }\n        const popped = this.queue.shift();\n        bfs.push(popped);\n  \n        if (this.graph[popped] === undefined) {\n        } else {\n          const childData = this.graph[popped];\n          for (let i of childData) {\n            this.queue.push(i);\n          }\n        }\n      }\n      return bfs;\n    };\n  }\n  `,\n  water_jug: `\n  class WaterJug():\n    def __init__(self,x,y,target):\n        self.capX = x\n        self.capY = y\n        self.x = 0\n        self.y = 0\n        self.targe,end='\\\\n\\\\n\\\\n't = target\n        self.path = []\n        \n    def rule(self,x, d=0):\n        w.printVolume()\n        print('Rule {}'.format(x),end=' ')\n        # fill capX gallon jug completely\n        if(x==1):\n                if self.x<self.capX:\n                    self.x=self.capX\n                print('Fill jugX completely')\n        # fill capY gallon jug completely\n        elif (x==2):\n                if self.y<self.capY:\n                    self.y=self.capY\n                print('Fill jugY completely')\n        # pour some part from x jug\n        elif(x==3):\n                if self.x>0:\n                    self.x= self.x - d\n                print('Pour Some part D from X jug')\n        # pour some part from y jug        \n        elif(x==4):\n                if self.y>0:\n                    self.y = self.y - d\n                \n                print('Pour Some part D from Y jug')\n        # empty jug x        \n        elif(x==5):\n                if self.x>0:\n                    self.x=0\n                print('Empty jugX')\n        # empty jug y        \n        elif(x==6):\n                if self.y>0:\n                    self.y=0\n                print('Empty jugY')\n        # pour water from y jug to fill x jug        \n        elif(x==7):\n                if self.x+self.y < self.capX+self.capY:\n                    self.y= self.y-(self.capX-self.x)\n                    self.x = self.capX\n                print('Pour from jugY to fill jugX')\n        #pour water from x jug to fill y jug\n        elif(x==8):\n                if self.x+self.y < self.capX+self.capY:\n                    self.x=self.x-(self.capY-self.y)\n                    self.y = self.capY\n                print('Pour from jugX to fill jugY')\n        # pour all water from y jug to x jug\n        elif(x==9):\n                if self.x+self.y < self.capX:\n                    self.x= self.x+self.y\n                    self.y=0\n                print('Pour all from jugY to jugX')\n        #pour all water from x jug to y jug\n        elif(x==10):\n                if self.x+self.y < self.capY:\n                    self.x=0\n                    self.y=self.x+self.y     \n                    print('Pour all from jugX to jugY')\n\n        w.printVolume()\n        print('---')\n        self.appendPath()\n             \n    def printVolume(self):\n        print('[JugX={}, JugY={}]'.format(self.x, self.y))\n    \n    # print each state leading upto solution\n    def printPath(self):\n        for state in self.path:\n            if state==self.path[-1]:\n                print(f'[JugX:{state[0]}, JugY:{state[1]}]')\n                continue\n            print(f'[JugX:{state[0]}, JugY:{state[1]}]', end='->')\n    \n    # add new state generated to path\n    def appendPath(self):\n        self.path.append([self.x, self.y])\n    \n    def reset(self):\n        self.x=0\n        self.y=0\n        self.path=[]\n        \n    def pour(self): \n        self.reset()\n        yJug= self.capY\n        xJug=0\n#         self.rule(2)\n        step = 1\n        while ((yJug  is not self.target) and (xJug is not self.target)): \n            print('({},{})'.format(xJug, yJug))\n            \n\n            if(yJug < (self.capX-xJug)):\n                temp = yJug\n#                 self.rule(9)\n            else:\n                temp = (self.capX-xJug)\n#                 self.rule(7)\n            xJug = xJug + temp\n            yJug = yJug - temp\n\n#             temp = min(yJug, self.capX-xJug) \n#             xJug = xJug + temp \n#             yJug = yJug - temp \n\n            print('({},{})'.format(xJug, yJug))\n\n            step =  step + 1\n            if ((yJug == self.target) or (xJug == self.target)): \n                break\n\n            if yJug == 0: \n                yJug = self.capY\n#                 self.rule(2)\n                step =  step + 1\n\n            if xJug == self.capX: \n                xJug = 0\n#                 self.rule(5)\n                step =  step + 1\n    \n    # Solve using rules\n    def pourRule(self):\n        self.reset()\n        self.rule(2)\n        step = 1\n        while(1):\n            if(self.y==self.target or self.x==self.target):\n                break\n            \n            if(self.y < (self.capX-self.x)):\n                self.rule(9)\n            else:\n                self.rule(7)\n            \n            step=step+1\n            if(self.y==self.target or self.x==self.target):\n                break\n            \n            if self.y==0:\n                self.rule(2)\n                step = step + 1\n            \n            if self.x==self.capX:\n                self.rule(5)\n                step = step+1\n        return step \n\n    # Reverse the capacity of jugs\n    def reverseJugCapacity(self):\n        self.capX, self.capY = self.capY, self.capX\n    \n    # Solve  for both x,y and y,x conditions \n    def solve(self):\n        print(f'With JugXCapacity {self.capX} and JugYCapacity {self.capY}',end='\\\\n\\\\n\\\\n')\n        print(f'Total steps to solve : {self.pourRule()}',end='\\\\n\\\\n')\n        self.printPath()\n        print('*'*100)\n        print(f'With JugXCapacity {self.capX} and JugYCapacity {self.capY}',end='\\\\n\\\\n\\\\n')\n        self.reverseJugCapacity()\n        print(f'Total steps to solve : {self.pourRule()}',end='\\\\n\\\\n')\n        self.printPath()\n  `,\n  water_jug_pour_rule: `\n  # Solve using rules\n  def pourRule(self):\n      self.reset()\n      self.rule(2)\n      step = 1\n      while(1):\n          if(self.y==self.target or self.x==self.target):\n              break\n          \n          if(self.y < (self.capX-self.x)):\n              self.rule(9)\n          else:\n              self.rule(7)\n          \n          step=step+1\n          if(self.y==self.target or self.x==self.target):\n              break\n          \n          if self.y==0:\n              self.rule(2)\n              step = step + 1\n          \n          if self.x==self.capX:\n              self.rule(5)\n              step = step+1\n      return step \n  `,\n  water_jug_rules: `\n  def rule(self,x, d=0):\n    w.printVolume()\n    print('Rule {}'.format(x),end=' ')\n    # fill capX gallon jug completely\n    if(x==1):\n            if self.x<self.capX:\n                self.x=self.capX\n            print('Fill jugX completely')\n    # fill capY gallon jug completely\n    elif (x==2):\n            if self.y<self.capY:\n                self.y=self.capY\n            print('Fill jugY completely')\n    # pour some part from x jug\n    elif(x==3):\n            if self.x>0:\n                self.x= self.x - d\n            print('Pour Some part D from X jug')\n    # pour some part from y jug        \n    elif(x==4):\n            if self.y>0:\n                self.y = self.y - d\n            \n            print('Pour Some part D from Y jug')\n    # empty jug x        \n    elif(x==5):\n            if self.x>0:\n                self.x=0\n            print('Empty jugX')\n    # empty jug y        \n    elif(x==6):\n            if self.y>0:\n                self.y=0\n            print('Empty jugY')\n    # pour water from y jug to fill x jug        \n    elif(x==7):\n            if self.x+self.y < self.capX+self.capY:\n                self.y= self.y-(self.capX-self.x)\n                self.x = self.capX\n            print('Pour from jugY to fill jugX')\n    #pour water from x jug to fill y jug\n    elif(x==8):\n            if self.x+self.y < self.capX+self.capY:\n                self.x=self.x-(self.capY-self.y)\n                self.y = self.capY\n            print('Pour from jugX to fill jugY')\n    # pour all water from y jug to x jug\n    elif(x==9):\n            if self.x+self.y < self.capX:\n                self.x= self.x+self.y\n                self.y=0\n            print('Pour all from jugY to jugX')\n    #pour all water from x jug to y jug\n    elif(x==10):\n            if self.x+self.y < self.capY:\n                self.x=0\n                self.y=self.x+self.y     \n                print('Pour all from jugX to jugY')\n\n    w.printVolume()\n    print('---')\n    self.appendPath()\n  `,\n  water_jug_solution: `\n  w = WaterJug(5,3,4)\n  w.solve()\n  \n  OUTPUT:\n    With JugXCapacity 5 and JugYCapacity 3\n\n\n    [JugX=0, JugY=0]\n    Rule 2 Fill jugY completely\n    [JugX=0, JugY=3]\n    ---\n    [JugX=0, JugY=3]\n    Rule 9 Pour all from jugY to jugX\n    [JugX=3, JugY=0]\n    ---\n    [JugX=3, JugY=0]\n    Rule 2 Fill jugY completely\n    [JugX=3, JugY=3]\n    ---\n    [JugX=3, JugY=3]\n    Rule 7 Pour from jugY to fill jugX\n    [JugX=5, JugY=1]\n    ---\n    [JugX=5, JugY=1]\n    Rule 5 Empty jugX\n    [JugX=0, JugY=1]\n    ---\n    [JugX=0, JugY=1]\n    Rule 9 Pour all from jugY to jugX\n    [JugX=1, JugY=0]\n    ---\n    [JugX=1, JugY=0]\n    Rule 2 Fill jugY completely\n    [JugX=1, JugY=3]\n    ---\n    [JugX=1, JugY=3]\n    Rule 9 Pour all from jugY to jugX\n    [JugX=4, JugY=0]\n    ---\n    Total steps to solve : 8\n\n    [JugX:0, JugY:3]-> [JugX:3, JugY:0]-> [JugX:3, JugY:3]-> [JugX:5, JugY:1]->\n    [JugX:0, JugY:1]-> [JugX:1, JugY:0]-> [JugX:1, JugY:3]-> [JugX:4, JugY:0]\n    *****************************************************\n    With JugXCapacity 5 and JugYCapacity 3\n\n\n    [JugX=0, JugY=0]\n    Rule 2 Fill jugY completely\n    [JugX=0, JugY=5]\n    ---\n    [JugX=0, JugY=5]\n    Rule 7 Pour from jugY to fill jugX\n    [JugX=3, JugY=2]\n    ---\n    [JugX=3, JugY=2]\n    Rule 5 Empty jugX\n    [JugX=0, JugY=2]\n    ---\n    [JugX=0, JugY=2]\n    Rule 9 Pour all from jugY to jugX\n    [JugX=2, JugY=0]\n    ---\n    [JugX=2, JugY=0]\n    Rule 2 Fill jugY completely\n    [JugX=2, JugY=5]\n    ---\n    [JugX=2, JugY=5]\n    Rule 7 Pour from jugY to fill jugX\n    [JugX=3, JugY=4]\n    ---\n    Total steps to solve : 6\n\n    [JugX:0, JugY:5]->[JugX:3, JugY:2]->[JugX:0, JugY:2]\n    ->[JugX:2, JugY:0]->[JugX:2, JugY:5]->[JugX:3, JugY:4]\n\n  `,\n  a_star_search_grid_generation: `\n  const generateGrid = (numbeOfRows, numberOfColumns, value) => {\n    return range(numbeOfRows).map((x) =>\n      range(numberOfColumns).map((y) => ({\n        ...value,\n        x,\n        y,\n      }))\n    );\n  };\n  `,\n  a_star_search_coord_and_distance: `\n  const coordinatesToCheck = [\n    { y: 0, x: -1 },\n    { y: 1, x: -1 },\n    { y: 1, x: 0 },\n    { y: 1, x: 1 },\n    { y: 0, x: 1 },\n    { y: -1, x: 1 },\n    { y: -1, x: 0 },\n    { y: -1, x: -1 },\n  ];\n  \n  const getDistance = (a, b) => {\n    const colOffset = Math.abs(a.y - b.y);\n    const rowOffset = Math.abs(a.x - b.x);\n    const numberOfStraightSegments = Math.abs(colOffset - rowOffset);\n    const numberOfDiagonalSegments =\n      Math.max(colOffset, rowOffset) - numberOfStraightSegments;\n  \n    return numberOfStraightSegments * 10 + numberOfDiagonalSegments * 14; // 14 ~ 10 * sqrt(2)\n  };  \n  `,\n\n  a_star_search_path_calculation: `  \n  export const computePath = (mainGrid, start, end) => {\n    const gridLength = mainGrid.length;\n\n    let counter = 0;\n    let openList = [];\n    const grid = generateGrid(gridLength, gridLength, {\n      fCost: 0,\n      gCost: 0,\n      hCost: 0,\n      parent: undefined,\n      isClosed: false,\n      isPath: false,\n      counter: 0,\n      x: 0,\n      y: 0,\n    });\n    openList.push(grid[start.x][start.y]);\n\n    while (openList.length > 0) {\n      const currentCell = minBy(openList, (c) => c.fCost);\n\n      if (!currentCell) {\n        // no path found\n        return grid;\n      }\n\n      if (currentCell.x === end.x && currentCell.y === end.y) {\n        let curr = currentCell;\n\n        while (curr.parent) {\n          grid[curr.x][curr.y].isPath = true;\n          curr = curr.parent;\n        }\n\n        return grid;\n      }\n\n      remove(openList, (c) => c.x === currentCell.x && c.y === currentCell.y);\n      currentCell.isClosed = true;\n      // eslint-disable-next-line no-loop-func\n      coordinatesToCheck.forEach((coordinatesToCheck) => {\n        const { x, y } = {\n          x: currentCell.x + coordinatesToCheck.x,\n          y: currentCell.y + coordinatesToCheck.y,\n        };\n\n        if (\n          x < 0 ||\n          x >= gridLength ||\n          y < 0 ||\n          y >= gridLength ||\n          (start.x === x && start.y === y) ||\n          grid[x][y].isClosed ||\n          mainGrid[x][y].status === \"blocked\"\n        ) {\n          return;\n        }\n\n        const neighbourCell = grid[x][y];\n\n        const gCost = currentCell.gCost + getDistance(currentCell, neighbourCell);\n        let gCostIsBest = false;\n\n        if (!openList.find((c) => c.x === x && c.y === y)) {\n          gCostIsBest = true;\n          neighbourCell.hCost = getDistance(neighbourCell, end);\n          openList.push(neighbourCell);\n        } else if (gCost < neighbourCell.gCost) {\n          gCostIsBest = true;\n        }\n\n        if (gCostIsBest) {\n          neighbourCell.parent = currentCell;\n          neighbourCell.gCost = gCost;\n          neighbourCell.fCost = neighbourCell.gCost + neighbourCell.hCost;\n          counter = counter + 1;\n          neighbourCell.counter = counter;\n        }\n      });\n    }\n    // No path found\n    return grid;\n  };\n  `,\n  chatbot: `\n  import natural from \"natural\";\n\n  class Chatbot {  \n    constructor(name = \"Agent\") {\n      this.name = name;\n      this.questions = {};\n    }\n  \n    addQuestionsAnswer = (questions, answer) => {\n      let question;\n      for (question of questions) {\n        this.questions[question] = answer;\n      }\n    };\n  \n    //  stem words (fast but abstract words)\n    stemSentence = (sentence) => {\n      return natural.PorterStemmer.tokenizeAndStem(sentence);\n    };\n  \n    ask = (question) => {\n      question = question.toLowerCase().trim();\n      const questionWordList = this.stemSentence(question);\n      let index = 0;\n      let match = [];\n      //console.log(questionWordList);\n      let ques;\n      for (ques of Object.keys(this.questions)) {\n        ques = ques.toLowerCase().trim();\n        //console.log(ques);\n        const quesWordList = this.stemSentence(ques);\n        // console.log(quesWordList);\n        match.push(0);\n        let count = 0;\n        let word;\n        for (word of quesWordList) {\n          count += 1;\n          if (questionWordList.includes(word)) {\n            match[index] += 1;\n          }\n        }\n        match[index] = match[index] / Math.max(count, 1);\n        index += 1;\n        //  console.log(ques)\n        //  console.log(question)\n        // if (ques.toLowerCase().trim() === question) {\n        //   console.log(match);\n  \n        //   console.log(match.index(match.max));\n        //   return this.questions[ques];\n        // }\n      }\n      console.log(match);\n      const max = Math.max(...match);\n      console.log(max);\n      if (max >= 0.3) {\n        //  [match.index(max(match))]\n        const bestQuestionMatch = Object.keys(this.questions)[match.indexOf(max)];\n        return this.questions[bestQuestionMatch];\n      }\n      return \"I did not understand the question!\";\n    };\n  \n    listQuestions = () => {\n      var question;\n      let questionList = [];\n      for (question of Object.keys(this.questions)) {\n        // console.log(question);\n        questionList.push(question);\n      }\n      // console.log(questionList);\n      return questionList;\n    };\n  \n    initiateChat = () => {\n      // console.log(\"Chat with {this.name}\");\n      // console.log(\"Availabe questions for {this.name}\");\n      this.listQuestions();\n  \n      while (1) {\n        //var question = prompt(\"Enter question for {this.name} \\n\");\n        const question = \"Hi\";\n        if (\n          [\n            \"quit\",\n            \"exit\",\n            \"close\",\n            \"stop\",\n            \"end\",\n            \".\",\n            \"annihilate\",\n            \"disconnect\",\n          ].includes(question)\n        ) {\n          break;\n        }\n        // console.log(\"{this.ask(question)}\");\n      }\n    };\n  }   \n  `,\n  chatbot_stem: `\n  //  stem words (fast but abstract words)\n  stemSentence = (sentence) => {\n    return natural.PorterStemmer.tokenizeAndStem(sentence);\n  };\n  `,\n  chatbot_ask: `\n  ask = (question) => {\n    question = question.toLowerCase().trim();\n    const questionWordList = this.stemSentence(question);\n    let index = 0;\n    let match = [];\n    //console.log(questionWordList);\n    let ques;\n    for (ques of Object.keys(this.questions)) {\n      ques = ques.toLowerCase().trim();\n      //console.log(ques);\n      const quesWordList = this.stemSentence(ques);\n      // console.log(quesWordList);\n      match.push(0);\n      let count = 0;\n      let word;\n      for (word of quesWordList) {\n        count += 1;\n        if (questionWordList.includes(word)) {\n          match[index] += 1;\n        }\n      }\n      match[index] = match[index] / Math.max(count, 1);\n      index += 1;\n      //  console.log(ques)\n      //  console.log(question)\n      // if (ques.toLowerCase().trim() === question) {\n      //   console.log(match);\n\n      //   console.log(match.index(match.max));\n      //   return this.questions[ques];\n      // }\n    }\n    console.log(match);\n    const max = Math.max(...match);\n    console.log(max);\n    if (max >= 0.3) {\n      //  [match.index(max(match))]\n      const bestQuestionMatch = Object.keys(this.questions)[match.indexOf(max)];\n      return this.questions[bestQuestionMatch];\n    }\n    return \"I did not understand the question!\";\n  };\n  `,\n};\n","import React, { forwardRef, useEffect, useState } from \"react\";\nimport { TweenMax } from \"gsap\";\nimport { Linear } from \"gsap/gsap-core\";\nimport { useImperativeHandle } from \"react\";\n\nconst WaterjugComponent = forwardRef((props, ref) => {\n  const { id, capacity = 3, height = 160, width = 160 } = props;\n\n  const [waterVolume, setWaterVolume] = useState(0);\n  const [emptyWaterVolume, setEmptyWaterVolume] = useState(capacity);\n  const [toggle, setToggle] = useState(0);\n  const [toggleRender, setToggleRender] = useState(false);\n  const [waterLevel, setWaterLevel] = useState(0);\n  const [temporaryLevel, setTemporaryLevel] = useState(0);\n\n  useImperativeHandle(ref, () => ({\n    fill(x) {\n      console.log(\"Fill\");\n      setWaterVolume(x);\n    },\n    drop(x) {\n      console.log(\"empty\");\n      setEmptyWaterVolume(x);\n    },\n    toggleButton(x) {\n      setToggle(x);\n      setToggleRender(!toggleRender);\n    },\n    empty() {\n      setToggleRender(!toggleRender);\n      setToggle(2);\n      setEmptyWaterVolume(temporaryLevel);\n    },\n  }));\n\n  useEffect(() => {\n    if (toggle === 1) {\n      const rise = waterLevel + waterVolume;\n      if (rise <= capacity) {\n        setWaterLevel(rise);\n        const waterRatio = (temporaryLevel + waterVolume) / capacity;\n        const previousRatio = temporaryLevel / capacity;\n        setTemporaryLevel(rise);\n        // \"Wave\" animation\n        TweenMax.fromTo(\n          \".water-fill\" + id,\n          0.8,\n          {\n            attr: {\n              x: -400,\n            },\n          },\n          {\n            attr: {\n              x: 0,\n            },\n            repeat: -1,\n            ease: Linear.easeNone,\n          }\n        );\n\n        // \"Fill up\" animation\n        TweenMax.fromTo(\n          \".water-fill\" + id,\n          3,\n          {\n            attr: {\n              y: 378 - 378 * previousRatio,\n              height: 440 * previousRatio,\n            },\n          },\n          {\n            attr: {\n              y: 378 - 378 * waterRatio,\n              height: 440 * waterRatio,\n            },\n            ease: Linear.easeNone,\n          }\n        );\n      }\n    } else if (toggle === 2) {\n      console.log(\"IN DROP id \" + id);\n      console.log(waterLevel, emptyWaterVolume);\n      const drop = waterLevel - emptyWaterVolume;\n      if (drop >= 0) {\n        setWaterLevel(drop);\n\n        const previousRatio = temporaryLevel / capacity;\n        const emptyWaterRatio = (temporaryLevel - emptyWaterVolume) / capacity;\n        setTemporaryLevel(drop);\n        // \"Wave\" animation\n        TweenMax.fromTo(\n          \".water-fill\" + id,\n          0.8,\n          {\n            attr: {\n              x: -400,\n            },\n          },\n          {\n            attr: {\n              x: 0,\n            },\n            repeat: -1,\n            ease: Linear.easeNone,\n          }\n        );\n\n        // \"Drop water\" animation\n        TweenMax.fromTo(\n          \".water-fill\" + id,\n          3,\n          {\n            attr: {\n              y: 378 - 378 * previousRatio,\n              height: 440 * previousRatio,\n            },\n          },\n          {\n            attr: {\n              y: 378 - 378 * emptyWaterRatio,\n              height: 440 * emptyWaterRatio,\n            },\n            ease: Linear.easeNone,\n          }\n        );\n      }\n    }\n  }, [toggleRender]);\n\n  return (\n    <>\n      <svg\n        id=\"Layer_1\"\n        height={height}\n        width={width}\n        data-name=\"Layer 1\"\n        xmlns=\"http://www.w3.org/2000/svg\"\n        viewBox=\"0 0 378 378\"\n      >\n        <defs>\n          <pattern\n            id=\"water\"\n            width=\".25\"\n            height=\"1.1\"\n            patternContentUnits=\"objectBoundingBox\"\n          >\n            <path\n              fill=\"#4A90E2\"\n              d=\"M0.25,1H0c0,0,0-0.659,0-0.916c0.083-0.303,0.158,0.334,0.25,0C0.25,0.327,0.25,1,0.25,1z\"\n            />\n          </pattern>\n\n          <g id=\"text\">\n            <circle cx=\"50%\" cy=\"50%\" r=\"50%\" />\n          </g>\n\n          <mask id=\"text-mask\">\n            <use x=\"0\" y=\"0\" href=\"#text\" opacity=\"1\" fill=\"#ffffff\" />\n          </mask>\n        </defs>\n\n        <use x=\"0\" y=\"0\" href=\"#text\" fill=\"#222\" />\n\n        <rect\n          className={\"water-fill\" + id}\n          mask=\"url(#text-mask)\"\n          fill=\"url(#water)\"\n          x=\"400\"\n          y=\"0\"\n          width=\"1600\"\n          height=\"100%\"\n        />\n        <text x=\"25%\" y=\"50%\" fill=\"white\" fontSize=\"5em\">\n          {`${waterLevel}L/${capacity}L`}\n        </text>\n      </svg>\n    </>\n  );\n});\n\nexport default React.memo(WaterjugComponent);\n","import {\n  Button,\n  Card,\n  CardContent,\n  Grid,\n  TextField,\n  Typography,\n} from \"@material-ui/core\";\nimport React, { useEffect, useRef, useState } from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport Waterjug from \"./Waterjug\";\nimport WaterJugClass from \"./WaterjugClass\";\nimport {\n  addCapacityX,\n  addCapacityY,\n  addTarget,\n  computePath,\n  selectCapacityX,\n  selectCapacityY,\n  selectPath,\n  reset,\n  stop,\n  selectStopAnimation,\n  selectTarget,\n} from \"./waterjugSlice\";\n\nconst water = new WaterJugClass(7, 5, 1);\n\nwater.pourRule();\nconst WaterjugComponent = () => {\n  const capX = useSelector(selectCapacityX);\n  const capY = useSelector(selectCapacityY);\n  const targt = useSelector(selectTarget);\n  const path = useSelector(selectPath);\n  const stop = useSelector(selectStopAnimation);\n  const refX = useRef(null);\n  const refY = useRef(null);\n\n  const [capacityX, setCapacityX] = useState(0);\n  const [capacityY, setCapacityY] = useState(0);\n\n  const [jugX, setJugX] = useState(0);\n  const [jugY, setJugY] = useState(0);\n  const [prevJugX, setPrevJugX] = useState(0);\n  const [prevJugY, setPrevJugY] = useState(0);\n\n  const [target, setTarget] = useState(0);\n\n  const dispatch = useDispatch();\n\n  function sleep(ms) {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n  const waitLoop = async () => {\n    var tempX = 0;\n    var tempY = 0;\n    for (var i of path) {\n      console.log(i);\n      const x = i[0];\n      const y = i[1];\n      setJugX(x);\n      setJugY(y);\n      setPrevJugX(tempX);\n      setPrevJugY(tempY);\n      console.log(x, y);\n      console.log(tempX, tempY);\n      if (x > tempX) {\n        refX.current.fill(x - tempX);\n        refX.current.toggleButton(1);\n      } else if (x < tempX) {\n        refX.current.drop(tempX - x);\n        refX.current.toggleButton(2);\n      }\n      // await sleep(3000);\n      if (y > tempY) {\n        refY.current.fill(y - tempY);\n        refY.current.toggleButton(1);\n      } else if (y < tempY) {\n        refY.current.drop(tempY - y);\n        refY.current.toggleButton(2);\n      }\n\n      tempX = x;\n      tempY = y;\n      if (stop) {\n        break;\n      } else {\n        await sleep(4000);\n      }\n    }\n  };\n  useEffect(() => {\n    if (refX.current !== null && refY.current !== null) {\n      if (path.length === 0) {\n        console.log(\"empty\");\n        refX.current.empty();\n        refY.current.empty();\n      } else {\n        try {\n          waitLoop();\n        } catch (e) {\n          console.log(e);\n        }\n      }\n    }\n  }, [path]);\n\n  const handleSubmit = (functionArguement, parameters) => {\n    dispatch(functionArguement(parameters));\n  };\n  return (\n    <Card>\n      <CardContent>\n        <Grid\n          container\n          xl={12}\n          spacing={4}\n          justify=\"center\"\n          alignItems=\"center\"\n        >\n          <Grid\n            item\n            container\n            xs={12}\n            spacing={2}\n            direction=\"row\"\n            justify=\"center\"\n            alignItems=\"center\"\n          >\n            <Card>\n              <CardContent>\n                <Grid\n                  item\n                  container\n                  xs={12}\n                  spacing={2}\n                  direction=\"row\"\n                  justify=\"center\"\n                  alignItems=\"center\"\n                >\n                  <Grid xs={12} sm={6} item container direction=\"column\">\n                    <Grid item>\n                      <Waterjug\n                        id={1}\n                        height=\"200\"\n                        width=\"200\"\n                        ref={refX}\n                        capacity={capX}\n                      />\n                    </Grid>\n                    <Grid item>\n                      <Button\n                        variant=\"outlined\"\n                        onClick={() => {\n                          refX.current.fill(2);\n                          refX.current.toggleButton(1);\n                        }}\n                      >\n                        Fill 2L\n                      </Button>\n                    </Grid>\n                    <Grid item>\n                      <Button\n                        variant=\"outlined\"\n                        onClick={() => {\n                          refX.current.drop(2);\n                          refX.current.toggleButton(2);\n                        }}\n                      >\n                        Drop 2L\n                      </Button>\n                    </Grid>\n                  </Grid>\n                  <Grid xs={12} sm={6} item container direction=\"column\">\n                    <Grid item>\n                      <Waterjug\n                        id={2}\n                        height=\"200\"\n                        width=\"200\"\n                        ref={refY}\n                        capacity={capY}\n                      />\n                    </Grid>\n                    <Grid item>\n                      <Button\n                        variant=\"outlined\"\n                        onClick={() => {\n                          refY.current.fill(2);\n                          refY.current.toggleButton(1);\n                        }}\n                      >\n                        Fill 2L\n                      </Button>\n                    </Grid>\n                    <Grid item>\n                      <Button\n                        variant=\"outlined\"\n                        onClick={() => {\n                          refY.current.drop(2);\n                          refY.current.toggleButton(2);\n                        }}\n                      >\n                        Drop 2L\n                      </Button>\n                    </Grid>\n                  </Grid>\n                </Grid>\n              </CardContent>\n            </Card>\n          </Grid>\n          <Grid\n            item\n            xs={12}\n            container\n            spacing={4}\n            direction=\"row\"\n            justify=\"center\"\n            alignItems=\"center\"\n          >\n            <Grid item>\n              <Typography>Jug Y Capacity : {capX}</Typography>\n            </Grid>\n            <Grid item>\n              <Typography>Jug X Capacity : {capY}</Typography>\n            </Grid>\n            <Grid item>\n              <Typography>Target : {targt}</Typography>\n            </Grid>\n          </Grid>{\" \"}\n          <Grid\n            item\n            xs={12}\n            container\n            spacing={4}\n            direction=\"row\"\n            justify=\"center\"\n            alignItems=\"center\"\n          >\n            <Grid item>\n              <TextField\n                label=\"Capacity For JUG X\"\n                plaardceholder=\"X Litre\"\n                variant=\"outlined\"\n                aria-label=\"Capacity Fot jug X\"\n                value={capacityX}\n                type=\"number\"\n                onChange={(e) => setCapacityX(e.target.value)}\n                onKeyPress={(e) => {\n                  if (e.key === \"Enter\")\n                    handleSubmit(addCapacityX, {\n                      capacityX: parseInt(capacityX),\n                    });\n                }}\n              />\n            </Grid>\n            <Grid item>\n              <TextField\n                label=\"Capacity For JUG Y\"\n                plaardceholder=\"Y Litre\"\n                variant=\"outlined\"\n                aria-label=\"Capacity Fot jug Y\"\n                value={capacityY}\n                type=\"number\"\n                onChange={(e) => setCapacityY(e.target.value)}\n                onKeyPress={(e) => {\n                  if (e.key === \"Enter\")\n                    handleSubmit(addCapacityY, {\n                      capacityY: parseInt(capacityY),\n                    });\n                }}\n              />\n            </Grid>\n            <Grid item>\n              <TextField\n                label=\"Target\"\n                plaardceholder=\"X Litre\"\n                variant=\"outlined\"\n                aria-label=\"Target\"\n                value={target}\n                type=\"number\"\n                onChange={(e) => setTarget(e.target.value)}\n                onKeyPress={(e) => {\n                  if (e.key === \"Enter\")\n                    handleSubmit(addTarget, { target: parseInt(target) });\n                }}\n              />\n            </Grid>\n          </Grid>\n          <Grid\n            item\n            container\n            spacing={2}\n            xs={12}\n            direction=\"row\"\n            justify=\"center\"\n            alignItems=\"center\"\n          >\n            <Grid item>\n              <Button\n                variant=\"contained\"\n                color=\"secondary\"\n                onClick={() => {\n                  dispatch(reset());\n\n                  refX.current.empty();\n                  refY.current.empty();\n                  dispatch(computePath());\n                }}\n              >\n                Compute Path\n              </Button>\n            </Grid>\n            <Grid item>\n              <Button\n                color=\"primary\"\n                variant=\"contained\"\n                onClick={() => {\n                  dispatch(reset());\n                }}\n              >\n                Reset\n              </Button>\n            </Grid>\n          </Grid>\n          <Grid\n            item\n            container\n            xs={12}\n            direction=\"row\"\n            justify=\"center\"\n            alignItems=\"center\"\n          >\n            {path.length > 0 ? (\n              <>\n                <Grid item xs={6}>\n                  <Typography align=\"center\">Current Transfer</Typography>\n                  <Typography align=\"center\">{`In JugX: ${prevJugX} -> ${jugX}`}</Typography>\n                  <Typography align=\"center\">{`In JugY: ${prevJugY} -> ${jugY}`}</Typography>\n                </Grid>\n              </>\n            ) : null}\n\n            <Grid\n              item\n              container\n              spacing={2}\n              xs={6}\n              direction=\"column\"\n              justify=\"center\"\n              alignItems=\"center\"\n            >\n              <Grid item>\n                <Typography>Steps Involved</Typography>\n              </Grid>\n              {path.length > 0\n                ? path.map((value, index) => {\n                    return (\n                      <Grid item key={index}>\n                        <Typography>{`JugX: ${value[0]}L, JugY:${value[1]}L`}</Typography>\n                      </Grid>\n                    );\n                  })\n                : null}\n            </Grid>\n          </Grid>\n        </Grid>\n      </CardContent>\n    </Card>\n  );\n};\nexport default WaterjugComponent;\n","import React from \"react\";\nimport { Grid } from \"@material-ui/core\";\n\nimport CodeBlock from \"../../components/CodeBlock\";\nimport { snippets } from \"../../snippets\";\nimport WaterjugComponent from \"../../features/waterjug/WaterjugComponent\";\n\nconst Lab3 = () => {\n  const tabNameList = [\"Solved Examples\", \"Rules\", \"Solution\", \"Class\"];\n  const tabCodeSnippetList = [\n    snippets.water_jug_solution,\n    snippets.water_jug_rules,\n    snippets.water_jug_pour_rule,\n    snippets.water_jug,\n  ];\n\n  return (\n    <Grid item container direction=\"column\" spacing={2}>\n      <Grid item>\n        <WaterjugComponent />\n      </Grid>\n\n      <Grid item xs={12} sm={12}>\n        <CodeBlock\n          tabNameList={tabNameList}\n          tabCodeSnippetList={tabCodeSnippetList}\n          language=\"javascript\"\n        />\n      </Grid>\n    </Grid>\n  );\n};\nexport default Lab3;\n"],"sourceRoot":""}